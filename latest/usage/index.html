<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The manual · GMT</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GMT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../examples/">Some examples</a></li><li class="current"><a class="toctext" href>The manual</a><ul class="internal"></ul></li><li><a class="toctext" href="../types/">The GMT types</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>The manual</a></li></ul><a class="edit-page" href="https://github.com/GenericMappingTools/GMT.jl/blob/master/docs/src/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The manual</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-multiple-usages-1" href="#The-multiple-usages-1">The multiple usages</a></h1><p>Access to GMT from Julia is accomplished via a main function (also called gmt), which offers full access to all of GMT’s ~140 modules as well as fundamental import, formatting, and export of GMT data objects. Internally, the GMT5 C API defines six high-level data structures (GMT6 will define only five) that handle input and output of data via GMT modules. These are data tables (representing one or more sets of points, lines, or polygons), grids (2-D equidistant data matrices), raster images (with 1–4 color bands), raw PostScript code, text tables (free-form text/data mixed records) and color palette tables (i.e., color maps). Correspondingly, we have defined five data structures that we use at the interface between GMT and Julia via the gmt function. The GMT.jl wrapper is responsible for translating between the GMT structures and native Julia structures, which are:</p><ul><li><p><strong>Grids</strong>: Many tools consider equidistant grids a particular data type and numerous file formats exist for saving such data. Because GMT relies on GDAL we are able to read and write almost all such formats in addition to a native netCDF4 format that complies with both the COARDS and CF netCDF conventions. We have designed a native Julia grid structure <a href="@ref"><code>GMTgrid</code></a> that holds header information from the GMT grid as well as the data matrix representing the gridded values. These structures may be passed to GMT modules that expect grids and are returned from GMT modules that produce such grids. In addition, we supply a function to convert a matrix and some metadata into a grid structure.</p></li><li><p><strong>Images</strong>: The raster image shares many characteristics with the grid structure except the bytes representing each node reflect gray shade, color bands (1, 3, or 4 for indexed, RGB and RGBA, respectively), and possibly transparency values. We therefore represent images in another native structure <a href="@ref"><code>GMTimage</code></a> that among other items contains three components: The image matrix, a color map (present for indexed images only), and an alpha matrix (for images specifying transparency on a per-pixel level). As for grids, a wrapper function creating the correct structure is available.</p></li><li><p><strong>Segments</strong>: GMT considers point, line, and polygon data to be organized in one or more segments in a data table. Modules that return segments uses a native Julia segment structure <a href="@ref"><code>GMTdataset</code></a> that holds the segment data, which may be either numerical, text, or both; it also holds a segment header string which GMT uses to pass metadata. Thus, GMT modules returning segments will typically produce arrays of segments and you may pass these to any other module expecting points, lines, or polygons or use them directly in Julia. Since a matrix is one fundamental data type you can also pass a matrix directly to GMT modules as well. Consequently, it is very easy to pass data from Julia into GMT modules that process data tables as well as to receive data segments from GMT modules that process and produce data tables as output.</p></li><li><p><strong>Color palettes</strong>: GMT uses its flexible Color Palette Table (CPT) format to describe how the color (or pattern) of symbols, lines, polygons or grids should vary as a function of a state variable. In Julia, this information is provided in another structure <a href="@ref"><code>GMTcpt</code></a> that holds the color map as well as an optional alpha array for transparency values. Like grids, these structures may be passed to GMT modules that expect CPTs and will be returned from GMT modules that normally would produce CPT files.</p></li><li><p><strong>PostScript</strong>: While most users of the GMT.jl wrapper are unlikely to manipulate PostScript directly, it allows for the passing of PostScript via another data structure <a href="@ref"><code>GMTps</code></a>.</p></li></ul><p>Given this design the Julia wrapper is designed to work in two distinct ways. The first way is the more feature reach and follows closely the GMT usage from shell(s) command line but still provide all the facilities of the Julia language. In this mode all <strong>GMT</strong> options are put in a single text string that is passed, plus the data itself when it applies, to the <span>$gmt()$</span> command. This function is invoked with the syntax (where the brackets mean optional parameters):</p><pre><code class="language-none">[output objects] = gmt(&quot;modulename optionstring&quot; [, input objects]);</code></pre><p>Let see an example to reproduce the CookBook example of an Hemisphere map using a Azimuthal projection.</p><pre><code class="language-none">gmt(&quot;pscoast -Rg -JA280/30/3.5i -Bg -Dc -A1000 -Gnavy -P &gt; GMT_lambert_az_hemi.ps&quot;)</code></pre><p>but that is not particularly interesting as after all we could do the exact same thing on the a shell command line. Things start to get interesting when we can send data <em>in</em> and <em>out</em> from Julia to <strong>GMT</strong>. So, consider the following example</p><footer><hr/><a class="previous" href="../examples/"><span class="direction">Previous</span><span class="title">Some examples</span></a><a class="next" href="../types/"><span class="direction">Next</span><span class="title">The GMT types</span></a></footer></article></body></html>
