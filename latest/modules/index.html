<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>By Modules · GMT</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GMT</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../examples/">Some examples</a></li><li><a class="toctext" href="../rectangles/">Draw rectangles examples</a></li><li><a class="toctext" href="../frames/">Draw frames examples</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../usage/">Introduction</a></li><li><a class="toctext" href="../monolitic/">Monolitic</a></li><li class="current"><a class="toctext" href>By Modules</a><ul class="internal"><li><a class="toctext" href="#Specifying-the-pen-attributes-1">Specifying the pen attributes</a></li><li><a class="toctext" href="#Specifying-the-axes-1">Specifying the axes</a></li><li><a class="toctext" href="#Specifying-the-figure-size-1">Specifying the figure size</a></li><li><a class="toctext" href="#The-output-format-1">The output format</a></li></ul></li></ul></li><li><a class="toctext" href="../types/">The GMT types</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>By Modules</a></li></ul><a class="edit-page" href="https://github.com/GenericMappingTools/GMT.jl/blob/master/docs/src/modules.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>By Modules</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="By-Modules-1" href="#By-Modules-1">By Modules</a></h1><p>In this mode we access the individual <strong>GMT</strong> modules directly by their name, and options are set using keyword arguments. The general syntax is (where the brackets mean optional parameters):</p><pre><code class="language-none">[output objects] = modulename([cmd::String=&quot;&quot;,] [argi=[];] opt1=val1, opt2=val2, kwargs...);</code></pre><p>where <em>modulename</em> is the program name (<em>e.g. coast</em>), <em>cmd</em> is used to transmit a file name for modules that will read data from files and <em>argi</em> is one, and for certain modules, or more data arrays or <em>GMT.jl</em> data types. <em>opti</em> named arguments common to many modules used for example to set the output format. Finally <em>kwargs</em> are keyword parameters used to set the individual module options. But contrary to the <a href="../monolitic/#Monolitic-1">Monolitic</a> usage, the one letter <em>GMT</em> option syntax may be replaced by more verbose aliases. To make it clear let us look at couple of examples.</p><pre><code class="language-none">coast(region=&quot;g&quot;, proj=&quot;A300/30/6c&quot;, frame=&quot;g&quot;, resolution=&quot;c&quot;, land=&quot;navy&quot;)</code></pre><p>This command creates a map in PotScript file called <em>GMTjl_tmp.ps</em> and save it in your system&#39;s <em>tmp</em> directory. For comparison, the same command could have been written, using the classical one letter option syntax, as:</p><pre><code class="language-none">coast(R=&quot;g&quot;, J=&quot;A300/30/6c&quot;, B=&quot;g&quot;, D=&quot;c&quot;, G=&quot;navy&quot;)</code></pre><p>So, each module defines a set of aliases to the one letter options that are reported in each module man page.</p><p>Before diving more in the way options may be transmitted into the module, we have to understand what happens with the output image file. By not directly specifying any format we are using the default output image format which is PostScript (actually, with the exception of <em>grdimage -A</em>, the only format that <em>GMT</em> can write). But we can select other formats by using the <em>fmt</em> keyword, for example <em>fmt=&quot;jpg&quot;</em>, or <em>fmt=&quot;png&quot;</em> or <em>fmt=&quot;pdf&quot;</em>. In such cases, the <em>ghostscript</em> program (you need to have it installed) will take care of converting the <em>ps</em> file into the selected format.</p><p>The above example, however, does not use any input data (<em>coast</em> knows how to find its own data). One way of providing it to modules that work on them is to send in a file name with the data to operate on. This example</p><pre><code class="language-none">grdimage(&quot;@tut_relief.nc&quot;, shade=&quot;+ne0.8+a100&quot;, proj=&quot;M12c&quot;, frame=&quot;a&quot;, show=true)</code></pre><p>reads a the netCDF grid <em>tut_relief.nc</em> and displays it as an Mercator projected image. The &#39;@&#39; prefix is used by <em>GMT</em> to know that the grid file should be downloaded from a server and cached locally. This example introduces also the <em>show=true</em> keyword. It means that we want to see right way the image that just been created. While it might seam obvious that one want to see the result, the result might not be ready with only one <em>GMT</em> module call. And that&#39;s because the <em>GMT</em> philosophy uses a <em>layer cake</em>  model to construct potentially highly complex figures. Next example illustrates a slightly more evolved example</p><pre><code class="language-none">topo = makecpt(color=&quot;rainbow&quot;, range=&quot;1000/5000/500&quot;, Z=[]);
grdimage(&quot;@tut_relief.nc&quot;, shade=&quot;+ne0.8+a100&quot;, proj=&quot;M12c&quot;, frame=&quot;a&quot;, color=topo,
         fmt=&quot;jpg&quot;)
scale!(position=&quot;jTC+w5i/0.25i+h+o0/-1i&quot;, region=&quot;@tut_relief.nc&quot;, color=topo,
       frame=&quot;y+lm&quot;, fmt=&quot;jpg&quot;, show=true)</code></pre><p>Here we used the <em>makecpt</em> command to compute a colormap object, used it as the value of the <em>color</em> keyword of both <em>grdimage</em> and <em>psscale</em> modules. The final image is made up of two layers, the first one is the part created by <em>grdimage</em>, which is complemented by the color scale plot performed by <em>psscale</em>. But since this was an appending operation we <strong>HAD</strong> to use the <strong>!</strong> form. This form tells <em>GMT</em> to append to a previous initiated image. The image layer cake is finalized by the <em>show=true</em> keyword. If our example had more layers, we would have used the same rule: second on layers use the <strong>!</strong> construct and the last is signaled by <em>show=true</em>.</p><p>The examples above show also that we didn&#39;t completely get rid of the compact <em>GMT</em> syntax. For example the <em>shade=&quot;+ne0.8+a100&quot;</em> in <em>grdimage</em> means that we are computing the shade using a normalized a cumulative Laplace distribution and setting the Sun direction from the 100 azimuth direction. For as much we would like to simplify that, it&#39;s just not possible. To access the high degree of control that <em>GMT</em> provides one need to use its full syntax. As such, readers are redirected to the main <em>GMT</em> documentation to learn about the fine details of those options.</p><p>Setting line and symbol attributes has received, however, a set of aliases. So, instead of declaring the pen line attributes like <em>-W0.5,blue,–</em>, one can use the aliases <em>lw=0.5, lc=&quot;blue&quot;, ls=&quot;–&quot;</em>. An example would be</p><pre><code class="language-none">plot(collect(1:10),rand(10), lw=0.5, lc=&quot;blue&quot;, ls=&quot;--&quot;, fmt=&quot;png&quot;, marker=&quot;circle&quot;,
     markeredgecolor=0, size=0.2, markerfacecolor=&quot;red&quot;, title=&quot;Bla Bla&quot;,
     x_label=&quot;Spoons&quot;, y_label=&quot;Forks&quot;, show=true)</code></pre><p>This example introduces also keywords to plot symbols and set their attributes. Also shown are the parameters used to set the image&#39;s title and labels.</p><p>But setting pen attributes like illustrated above may be complicated if one has more that one set of graphical objects (lines and polygons) that need to receive different settings. A good example of this again provide by a <em>coast</em> command. Imagine one want to plot coast lines ans well as country borders with different line colors and thickness. Here we cannot simple state <em>lw=1</em> because the program wouldn&#39;t know which of the shore line or borders this attribute applies to. The solution for this is to use tuples as values of corresponding keyword options.</p><pre><code class="language-none">coast(limits=&quot;-10/0/35/45&quot;, proj=&quot;M12c&quot;, shore=(0.5,&quot;red&quot;), frame=&quot;a&quot;,
        show=1, borders=(1,(1,&quot;green&quot;)))</code></pre><p>Here we used tuples to set the pen attributes, where the tuple may have 1 to 3 elements in the form (width[c|i|p]], [color], [style[c|i|p|]). The <em>borders=(1,(1,&quot;green&quot;))</em> option is actually a tuple-in-a-tuple because here we need also to specify the political boundary level to plot (1 = National Boundaries).</p><h2><a class="nav-anchor" id="Specifying-the-pen-attributes-1" href="#Specifying-the-pen-attributes-1">Specifying the pen attributes</a></h2><p>So, in summary, a <em>pen</em> attribute may be set in three different ways:</p><ol><li><p>With a text string that follows the <em>width</em>, <em>color</em>, <em>style</em> specs as explained in <a href="http://gmt.soest.hawaii.edu/doc/latest/GMT_Docs.html#specifying-pen-attributes"><code>Specifying pen attributes</code></a></p></li><li><p>By using the <strong>lw</strong> or <strong>linewidth</strong> keyword where its value is either a number, meaning the line thickness in points, or a string like the <em>width</em> above; the color is set with the <strong>lc</strong> or <strong>linecolor</strong> and the value is either a number between <em>[0 255]</em> (meaning a gray shade) or a color name (for example &quot;red&quot;); and a <strong>ls</strong> or <strong>linestyle</strong> with the value specified as a string (example: &quot;- -&quot; plot a dashed line).</p></li><li><p>A tuple with one to three elements: ([<em>width</em>], [<em>color</em>], [<em>style</em>]) where each of the elements follows the same syntax as explained in the case (2) above.</p></li></ol><h2><a class="nav-anchor" id="Specifying-the-axes-1" href="#Specifying-the-axes-1">Specifying the axes</a></h2><p>The axes are controlled by the <strong>B</strong> or <strong>frame</strong> or <strong>axes</strong> keywords. The easiest for it can have is the <em>axes=&quot;a&quot;</em>, which means do an automatic annotation of the 4 map boundaries – left, bottom, right and top – axes. To annotate only the left and bottom boundaries, one would do <em>axes=&quot;a WSne&quot;</em>. For a higher level of control the user must really consult the original <a href="http://gmt.soest.hawaii.edu/doc/latest/gmt.html#b-full"><code>-B documentation</code></a>.</p><p>Axes titles and labels may be also set. That is, other than setting them with a <strong>axes</strong> string, using the keywords <strong>title</strong>, <strong>x_label</strong> and <strong>y_label</strong>.</p><p>The figure limits is set with the <strong>R</strong>, <strong>region</strong> or <strong>limits</strong>  keywords. Again, the full docs for this option are explained in <a href="http://gmt.soest.hawaii.edu/doc/latest/gmt.html#r-full"><code>-R documentation</code></a> but besides the string version, the numeric form <em>region=[x_min x_max y_min y_max]</em> is also permitted. The <span>$plot()$</span> function allows that a no limits setting, in which case it will default to the data&#39;s bounding box.</p><h2><a class="nav-anchor" id="Specifying-the-figure-size-1" href="#Specifying-the-figure-size-1">Specifying the figure size</a></h2><p>Figure sizes are automatically set to 12x8 cm for basic case of Cartesian <em>xy</em> plots done with the <em>plot()</em> function but otherwise in general they need to be user specified using the <strong>J</strong> or <strong>proj</strong> or <strong>projection</strong> keywords. See the full doc at <a href="http://gmt.soest.hawaii.edu/doc/latest/gmt.html#j-full"><code>-J documentation</code></a>.  For Cartesian plots one can also use the <em>figsize=width</em>  or <em>figsize=[width height]</em> keyword, where the dimensions are in centimiters. The array form allows also set <em>height</em> or <em>width</em> to 0 to have it recomputed based on the implied scale of the other axis. Use negative sizes to reverse the direction of an axis (e.g., to have y be positive down). If neither of these forms is used, the figure width defaults to 14 cm.</p><h2><a class="nav-anchor" id="The-output-format-1" href="#The-output-format-1">The output format</a></h2><p>It was referred above that the <strong>fmt</strong> determines the output format and that the default is PostScript. Actually the default format is choosen by the contents of the global <strong>FMT</strong> variable set at the top of the <em>GMT.jl</em> file. Eventually this will evolve to using an evironment variable but for the moment users will have to edit that file to set a different default format.</p><p>A very interesting alternative is to set <strong>FMT=&quot;&quot;</strong>, that is to not specify any image format. This will result in <em>NOT</em> saving any file on disk but to keep the PS figure internally stored in the program&#39;s memory.  In other words the figure is built and kept in memory only. This allows converting to another format directly without the use of an intermediary disk file. The conversion is performed by the <em>psconvert</em> <em>GMT</em> module (not yet ported to an stand-alone function) that would be used like this (to convert to PDF):</p><pre><code class="language-none">gmt(&quot;psconvert = -A -Tf -Fmyfig.pdf&quot;)</code></pre><p>The issue with this solution, that could be implemented internally without user intervention, is that it currently only works on Windows.</p><p>A very interesting alternative to a file format is the option to create RGB images with <em>psconvert</em> and return it to Julia in a <a href="../types/#Image-type-1">Image type</a> type.</p><pre><code class="language-none">I = gmt(&quot;psconvert = -A&quot;)</code></pre><p>but again, so far on Windows only. A cool thing to develop would be the possibility to display this <em>I</em> image with the <a href="https://github.com/JuliaImages/Images.jl"><code>Images.jl</code></a> package.</p><footer><hr/><a class="previous" href="../monolitic/"><span class="direction">Previous</span><span class="title">Monolitic</span></a><a class="next" href="../types/"><span class="direction">Next</span><span class="title">The GMT types</span></a></footer></article></body></html>
