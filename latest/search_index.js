var documenterSearchIndex = {"docs": [

{
    "location": "usage/#",
    "page": "Introduction",
    "title": "Introduction",
    "category": "page",
    "text": ""
},

{
    "location": "usage/#Introduction-1",
    "page": "Introduction",
    "title": "Introduction",
    "category": "section",
    "text": "Access to GMT from Julia is accomplished via a main function (also called gmt), which offers full access to all of GMT’s ~140 modules as well as fundamental import, formatting, and export of GMT data objects. Internally, the GMT5 C API defines six high-level data structures (GMT6 will define only five) that handle input and output of data via GMT modules. These are data tables (representing one or more sets of points, lines, or polygons), grids (2-D equidistant data matrices), raster images (with 1–4 color bands), raw PostScript code, text tables (free-form text/data mixed records) and color palette tables (i.e., color maps). Correspondingly, we have defined five data structures that we use at the interface between GMT and Julia via the gmt function. The GMT.jl wrapper is responsible for translating between the GMT structures and native Julia structures, which are:Grids: Many tools consider equidistant grids a particular data type and numerous file formats exist for saving such data. Because GMT relies on GDAL we are able to read and write almost all such formats in addition to a native netCDF4 format that complies with both the COARDS and CF netCDF conventions. We have designed a native Julia grid structure Grid type that holds header information from the GMT grid as well as the data matrix representing the gridded values. These structures may be passed to GMT modules that expect grids and are returned from GMT modules that produce such grids. In addition, we supply a function to convert a matrix and some metadata into a grid structure.\nImages: The raster image shares many characteristics with the grid structure except the bytes representing each node reflect gray shade, color bands (1, 3, or 4 for indexed, RGB and RGBA, respectively), and possibly transparency values. We therefore represent images in another native structure Image type that among other items contains three components: The image matrix, a color map (present for indexed images only), and an alpha matrix (for images specifying transparency on a per-pixel level). As for grids, a wrapper function creating the correct structure is available.\nSegments: GMT considers point, line, and polygon data to be organized in one or more segments in a data table. Modules that return segments uses a native Julia segment structure Dataset type that holds the segment data, which may be either numerical, text, or both; it also holds a segment header string which GMT uses to pass metadata. Thus, GMT modules returning segments will typically produce arrays of segments and you may pass these to any other module expecting points, lines, or polygons or use them directly in Julia. Since a matrix is one fundamental data type you can also pass a matrix directly to GMT modules as well. Consequently, it is very easy to pass data from Julia into GMT modules that process data tables as well as to receive data segments from GMT modules that process and produce data tables as output.\nColor palettes: GMT uses its flexible Color Palette Table (CPT) format to describe how the color (or pattern) of symbols, lines, polygons or grids should vary as a function of a state variable. In Julia, this information is provided in another structure CPT type that holds the color map as well as an optional alpha array for transparency values. Like grids, these structures may be passed to GMT modules that expect CPTs and will be returned from GMT modules that normally would produce CPT files.\nPostScript: While most users of the GMT.jl wrapper are unlikely to manipulate PostScript directly, it allows for the passing of PostScript via another data structure Postscript type.Given this design the Julia wrapper is designed to work in two distinct ways. The first way, referred as the monolitic, is the more feature reach and follows closely the GMT usage from shell(s) command line but still provide all the facilities of the Julia language. See the Monolithic for the Reference on how to use the Package.\nThe second way uses an upper level set of functions that abstract aspects that make the monolitic usage more complex. It provides an interface to some of the GMT modules using a option=val list type syntax. This makes it more appropriate for newcommers but it won\'t release you from understanding the monolitic way. See the By Modules"
},

{
    "location": "examples/#",
    "page": "Some examples",
    "title": "Some examples",
    "category": "page",
    "text": ""
},

{
    "location": "examples/#Examples-1",
    "page": "Some examples",
    "title": "Examples",
    "category": "section",
    "text": ""
},

{
    "location": "examples/#Here\'s-the-\"Hello-World\"-1",
    "page": "Some examples",
    "title": "Here\'s the \"Hello World\"",
    "category": "section",
    "text": "using GMT\nplot(collect(1:10),rand(10), lw=1, lc=\"blue\", fmt=\"png\", marker=\"square\",\n     markeredgecolor=0, size=0.2, markerfacecolor=\"red\", title=\"Hello World\",\n     x_label=\"Spoons\", y_label=\"Forks\", show=true)<div style=\"width:300px; height=200px\"> (Image: \"Hello world\") </div>A few notes about this example. Because we didn\'t specify the figure size (with the figsize keyword) a default value of 12x8 cm (not counting labels and title) was used. The fmt=png selected the PNG format. The show=true is needed to show the image at the end.But now we want an image made up with two layers of data. And we are going to plot on the sphere (the Earth). For that we will need to use the coast program to plot the Earth and append some curvy lines."
},

{
    "location": "examples/#And-the-\"Hello-Round-World\"-1",
    "page": "Some examples",
    "title": "And the \"Hello Round World\"",
    "category": "section",
    "text": "x = range(0, stop=2pi, length=180);       seno = sin.(x/0.2)*45;\ncoast(region=[0 360 -90 90], proj=\"A300/30/6c\", frame=\"g\", resolution=\"c\", land=\"navy\")\n\nplot!(collect(x)*60, seno, lw=0.5, lc=\"red\", fmt=\"png\", marker=\"circle\",\n      markeredgecolor=0, size=0.05, markerfacecolor=\"cyan\", show=true)In this example region=[0 360 -90 90]  means the domain is the whole Earth, frame=\"g\" sets the grid on, resolution=\"c\" selects the crude coast lines resolution and the  land=\"navy\" paints the continents with a navy blue color. More complex is the proj=\"A300/30/6c\" argument that selects the map projection, which is a Lambert projection with projection center at 300 degrees East, 0 degrees North. The 6c sets the map width of 6 centimeters.(Image: \"Hello round world\")Note that now the first command, the coast, does not have the show keyword. It means we are here creating the first layer but we don\'t want to see it just yet. The second command uses the ! variation of the plot function, which means that we are appending to a previous plot, and uses the show=true because we are donne with this figure."
},

{
    "location": "examples/#Simple-contours-1",
    "page": "Some examples",
    "title": "Simple contours",
    "category": "section",
    "text": "Contours are created with grdcontour that takes a grid as input (or a GMTgrid data type). This example shows uses the peaks function to create a classical example. Note, however, that the memory consumption in this example, when creating the plot, is much lower than traditional likewise  examples because we will be using only one 2D array intead of 3 3D arrays (ref). In the example cont=1 and annot=2 means draw contours at evry 1 unit of the G grid and annotate at evry other contour line. frame=\"a\" means pick a default automatic annotation and labeling for the axis.x,y,z=GMT.peaks()\nG = gmt(\"surface -R-3/3/-3/3 -I0.1\", [x[:] y[:] z[:]]);  # Iterpolate into a regular grid\ngrdcontour(G, cont=1, annot=2, frame=\"a\", fmt=\"png\", show=1)(Image: \"Simple black&white contour\")Now with colored contours. To make it colored we need to generate a color map and use it. Notetice that we have to specify a pen attribute to get the colored contours because pen specifications are always set separately. Here we will create first a colormap with makecpt that will from -6 to 8 with steps of 1. These values are picked up after the z values of the G grid. cpt = makecpt(range=\"-6/8/1\");      # Create the color map\ngrdcontour(G, frame=\"a\", fmt=\"png\", color=cpt, pen=\"+c\", show=1)(Image: \"Simple color contour\")"
},

{
    "location": "examples/#Color-images-1",
    "page": "Some examples",
    "title": "Color images",
    "category": "section",
    "text": "Color images are made with grdimage which takes the usual common options and a color map. It operates over grids or images. The next example shows how to create a color appropriate for the grid\'s z range, plot the image and add a color scale. We use here the data keyword to tell the program to load the grid from a file. The  before the tut_relief.nc file name instructs GMT to download the file from its server on the first usage and save it in a cache dir. See the GMT tuturial for more details about what the arguments mean.topo = makecpt(color=\"rainbow\", range=\"1000/5000/500\", continuous=true);\ngrdimage(\"@tut_relief.nc\", shade=\"+ne0.8+a100\", proj=\"M12c\", frame=\"a\", fmt=\"jpg\",\n         color=topo)\ncolorbar!(position=\"jTC+w5i/0.25i+h+o0/-1i\", region=[-108 -103 35 40], color=topo,\n       proj=[], frame=\"y+lm\", fmt=\"jpg\", show=1)(Image: \"Hello shaded world\")"
},

{
    "location": "examples/#Perspective-view-1",
    "page": "Some examples",
    "title": "Perspective view",
    "category": "section",
    "text": "We will make a perspective, color-coded view of the US Rockies from the southeast.topo = makecpt(color=\"rainbow\", range=\"1000/5000/500\", continuous=true);\ngrdview(\"@tut_relief.nc\", proj=\"M12c\", JZ=\"1c\", shade=\"+ne0.8+a100\", view=\"135/30\",\n        frame=\"a\", fmt=\"jpg\", color=topo, Q=\"i100\", show=1)(Image: \"Hello 3D view world\")"
},

{
    "location": "examples/#Warp-image-in-geographical-projection-1",
    "page": "Some examples",
    "title": "Warp image in geographical projection",
    "category": "section",
    "text": "In this example we will load a network image (GDAL will do that for us) and make a creative world map. First command, the imshow, needs to set show=false to no display the image before it is complete. We have to do this because imshow is a one command only shot and so, by default, it has the show keyword hardwire to true.imshow(\"http://larryfire.files.wordpress.com/2009/07/untooned_jessicarabbit.jpg\",\n      frame=\"g\", region=\"d\", proj=\"I15c\", image_in=\"r\", show=false)\ncoast!(shore=\"1,white\", resolution=\"c\", fmt=\"png\", show=true)(Image: SinuJessica)"
},

{
    "location": "rectangles/#",
    "page": "Draw rectangles examples",
    "title": "Draw rectangles examples",
    "category": "page",
    "text": ""
},

{
    "location": "rectangles/#Draw-rectangles-1",
    "page": "Draw rectangles examples",
    "title": "Draw rectangles",
    "category": "section",
    "text": ""
},

{
    "location": "rectangles/#Simple-filled-rectangle-1",
    "page": "Draw rectangles examples",
    "title": "Simple filled rectangle",
    "category": "section",
    "text": "using GMT\nrect = [2 2; 2 6; 6 6; 6 2; 2 2];\nplot(rect, region=[0 10 0 10], lw=1, fill=\"blue\", frame=\"a\", axis=\"equal\", fmt=\"png\", show=true)(Image: \"Blue rectangle\")"
},

{
    "location": "rectangles/#Rectangles-with-patterns-1",
    "page": "Draw rectangles examples",
    "title": "Rectangles with patterns",
    "category": "section",
    "text": "Now add some patterns. The full pattern syntax is explained in GMT patterns but basically we are using pattern number 20 at 200 dpi and a blue background for the left rectangle and pattern 89 also at 200 dpis for the right rectangle.using GMT\nrect = [1 1; 1 7; 4 7; 4 1; 1 1];\nplot(rect, region=[0 10 0 10], lw=1, fill=\"p20+bgreen+r200\", frame=\"a\", axis=\"equal\")\nplot!([4 0].+rect, lw=1, fill=\"p89+r200\", fmt=\"png\", show=true)(Image: \"Pattern Rectangles\")"
},

{
    "location": "rectangles/#Rectangles-with-transparency-1",
    "page": "Draw rectangles examples",
    "title": "Rectangles with transparency",
    "category": "section",
    "text": "This variation creates rectangles with 0, 30% and 70% transparency as well as different boundary lines.using GMT\nrect = [0.5 0.5; 0.5 7; 2.5 7; 2.5 0.5; 0.5 0.5];\nplot(rect, region=[0 10 0 10], lw=0.5, fill=\"blue\", frame=\"a\", axis=\"equal\")\nplot!([3 0].+rect, lw=1, ls=\"--\", fill=\"blue\", transparency=30)\nplot!([6 0].+rect, lw=2, lc=\"red\", fill=\"blue\", transparency=70, fmt=\"png\", show=true)(Image: \"Transparent Rectangles\")"
},

{
    "location": "frames/#",
    "page": "Draw frames examples",
    "title": "Draw frames examples",
    "category": "page",
    "text": ""
},

{
    "location": "frames/#Draw-Frames-1",
    "page": "Draw frames examples",
    "title": "Draw Frames",
    "category": "section",
    "text": ""
},

{
    "location": "frames/#Geographic-basemaps-1",
    "page": "Draw frames examples",
    "title": "Geographic basemaps",
    "category": "section",
    "text": "Geographic basemaps may differ from regular plot axis in that some projections support a “fancy” form of axis and is selected by the MAPFRAMETYPE setting. The annotations will be formatted according to the FORMATGEOMAP template and MAPDEGREESYMBOL setting. A simple example of part of a basemap is shown in Figure Geographic map border.using GMT\nbasemap(limits=\"-1/2/0/0.4\", proj=:M8, frame=\"a1f15mg5m S\")\nt = [-1.0 0 0 1.0\n    0.25 0 0 0.25\n    1.25 0 0 0.08333332];\nGMT.xy!(t, symbol=\"v2p+b+e+a60\", lw=0.5, fill=:black, y_offset=-1.0, no_clip=true)\nif (GMTver < 6)\n    T = [\"-0.5 0.05 annotation\", \"0.375 0.05 frame\", \"1.29166666 0.05 grid\"];\nelse\n    T = text_record([-0.5 0.05; 0.375 0.05; 1.29166666 0.05], [\"annotation\", \"frame\", \"grid\"]);\nend\ntext!(T, text_attrib=\"+f9p+jCB\", fmt=:png, show=true)(Image: \"B_geo_1\")The machinery for primary and secondary annotations axes can be utilized for geographic basemaps. This may be used to separate degree annotations from minutes- and seconds-annotations. For a more complicated basemap example using several sets of intervals, including different intervals and pen attributes for grid lines and grid crosses.using GMT\nbasemap(region=\"-2/1/0/0.35\", proj=:M10, frame=\"pa15mf5mg5m wSe s1f30mg15m\", conf=(MAP_FRAME_TYPE=\"fancy+\",\n	MAP_GRID_PEN_PRIMARY=\"thinnest,black,.\", MAP_GRID_CROSS_SIZE_SECONDARY=0.25, MAP_FRAME_WIDTH=0.2,\n	MAP_TICK_LENGTH_PRIMARY=0.25, FORMAT_GEO_MAP=\"ddd:mm:ssF\", FONT_ANNOT_PRIMARY=\"+8\", FONT_ANNOT_SECONDARY=12))\n# Draw Arrows and text\nt = [-1.875 0 0 0.33333\n    -0.45833 0 0 0.11111\n    0.541666 0 0 0.11111]\nGMT.xy!(t, symbol=\"v0.08+b+e+jc\", lw=0.5, fill=:black, y_offset=-1, no_clip=true)\nif (GMTver < 6)\n    T = [\"-2.1 0.025 10p RM P:\", \"-1.875 0.05 6p CB annotation\",\n         \"-0.45833 0.05 6p CB frame\", \"0.541666 0.05 6p CB grid\"]\nelse\n    T = text_record([-2.1 0.025; -1.875 0.05; -0.45833 0.05; 0.541666 0.05], [\"10p RM P:\", \"6p CB annotation\", \"6p CB frame\", \"6p CB grid\"])\nend\ntext!(T, text_attrib=\"+f+j\", no_clip=true)\nt = [-1.5 0 0 1.33333; -0.25 0 0 0.66666; 0.625 0 0 0.33333]\nGMT.xy!(t, symbol=\"v0.08+b+e+jc\", lw=0.5, fill=:black, y_offset=-0.6, no_clip=true)\n\nif (GMTver < 6)\n    T = [\"-2.1 0.025 10p RM S:\", \"-1.5  0.05 9p CB annotation\",\n         \"-0.25 0.05 9p CB frame\", \"0.625 0.05 9p CB grid\"]\nelse\n    T = text_record([-2.1 0.025; -1.5  0.05; -0.25 0.05; 0.625 0.05], [\"10p RM S:\", \"9p CB annotation\", \"9p CB frame\", \"9p CB grid\"])\nend\ntext!(T, text_attrib=\"+f+j\", no_clip=true, fmt=:png, show=true)(Image: \"B_geo_2\")"
},

{
    "location": "frames/#Cartesian-linear-axes-1",
    "page": "Draw frames examples",
    "title": "Cartesian linear axes",
    "category": "section",
    "text": "For non-geographic axes, the MAPFRAMETYPE setting is implicitly set to plain. Other than that, cartesian linear axes are very similar to geographic axes. The annotation format may be controlled with the FORMATFLOATOUT parameter. By default, it is set to “%g”, which is a C language format statement for floating point numbers, and with this setting the various axis routines will automatically determine how many decimal points should be used by inspecting the stride settings. If FORMATFLOATOUT is set to another format it will be used directly (.e.g, “%.2f” for a fixed, two decimals format). Note that for these axes you may use the unit setting to add a unit string to each annotation.using GMT\nbasemap(region=\"0/12/0/1\", proj=\"X12/1\", frame=\"-Ba4f2g1+lFrequency+u\\\" \\%\\\" S\")\nt = [0 0 0 1.57; 6.0 0 0 0.79; 9.0 0 0 0.39]\nGMT.xy!(t, symbol=\"v2p+b+e+a60\", lw=0.5, fill=:black, y_offset=0.25, no_clip=true)\nif (GMTver < 6)\n    T = [\"2 0.2 annotation\"; \"7 0.2 frame\"; \"9.5 0.2 grid\"]\nelse\n    T = text_record([2 0.2; 7 0.2; 9.5 0.2], [\"annotation\", \"frame\", \"grid\"])\nend\ntext!(T, text_attrib=\"+f9p+jCB\", clearance=\"0.025/0.025\", fill=:white, fmt=:png, show=true)(Image: \"B_linear\")"
},

{
    "location": "frames/#Cartesian-log10-axes-1",
    "page": "Draw frames examples",
    "title": "Cartesian log10 axes",
    "category": "section",
    "text": "Due to the logarithmic nature of annotation spacings, the stride parameter takes on specific meanings. The following concerns are specific to log axes (see Figure Logarithmic projection axis):stride must be 1, 2, 3, or a negative integer -n. Annotations/ticks will then occur at 1, 1-2-5, or 1,2,3,4,...,9, respectively, for each magnitude range. For -n the annotations will take place every n‘th magnitude.\nAppend l to stride. Then, log10 of the annotation is plotted at every integer log10 value (e.g., x = 100 will be annotated as “2”) [Default annotates x as is].\nAppend p to stride. Then, annotations appear as 10 raised to log10 of the value (e.g., 10-5).using GMT\ngmt(\"set MAP_GRID_PEN_PRIMARY thinnest,.\")\nbasemap(region=\"1/1000/0/1\", proj=\"X8l/0.7\", frame=\"1f2g3p+l\\\"Axis Label\\\" S\")\nbasemap!(frame=\"1f2g3l+l\\\"Axis Label\\\" S\", y_offset=2.2)\nbasemap!(frame=\"1f2g3+l\\\"Axis Label\\\" S\", y_offset=2.2, fmt=:png, show=true)(Image: \"B_log\")"
},

{
    "location": "frames/#Cartesian-exponential-axes-1",
    "page": "Draw frames examples",
    "title": "Cartesian exponential axes",
    "category": "section",
    "text": "Normally, stride will be used to create equidistant (in the user’s unit) annotations or ticks, but because of the exponential nature of the axis, such annotations may converge on each other at one end of the axis. To avoid this problem, you can append p to stride, and the annotation interval is expected to be in transformed units, yet the annotation itself will be plotted as un-transformed units. E.g., if stride = 1 and power = 0.5 (i.e., sqrt), then equidistant annotations labeled 1, 4, 9, ... will appear.using GMT\ngmt(\"set MAP_GRID_PEN_PRIMARY thinnest,.\")\nbasemap(region=\"0/100/0/0.9\", proj=\"X3ip0.5/0.25i\", frame=\"a3f2g1p+l\\\"Axis Label\\\" S\")\nbasemap!(frame=\"20f10g5+l\\\"Axis Label\\\" S\",  y_offset=2.2, fmt=:png, show=true)(Image: \"B_pow\")"
},

{
    "location": "frames/#Cartesian-time-axes-1",
    "page": "Draw frames examples",
    "title": "Cartesian time axes",
    "category": "section",
    "text": "What sets time axis apart from the other kinds of plot axes is the numerous ways in which we may want to tick and annotate the axis. Not only do we have both primary and secondary annotation items but we also have interval annotations versus tick-mark annotations, numerous time units, and several ways in which to modify the plot. We will demonstrate this flexibility with a series of examples. While all our examples will only show a single x-axis (south, selected via -BS), time-axis annotations are supported for all axes.Our first example shows a time period of almost two months in Spring 2000. We want to annotate the month intervals as well as the date at the start of each week. Note the leading hyphen in the FORMATDATEMAP removes leading zeros from calendar items (e.g., 03 becomes 3).using GMT\nbasemap(region=\"2000-4-1T/2000-5-25T/0/1\", proj=\"X12/0.5\", frame=\"pa7Rf1d sa1O S\",\n        conf=(FORMAT_DATE_MAP=\"-o\", FONT_ANNOT_PRIMARY=\"+9p\"), fmt=:png, show=true)(Image: \"B_time1\")The next example shows two different ways to annotate an axis portraying 2 days in July 1969:using GMT\ngmt(\"set FORMAT_DATE_MAP \\\"o dd\\\" FORMAT_CLOCK_MAP hh:mm FONT_ANNOT_PRIMARY +9p\")\nbasemap(region=\"1969-7-21T/1969-7-23T/0/1\", proj=\"X12/0.5\", frame=\"pa6Hf1h sa1K S\")\nbasemap!(frame=\"pa6Hf1h sa1D S\", y_offset=1.7, fmt=:png, show=true)The lower example chooses to annotate the weekdays (by specifying a1K) while the upper example choses dates (by specifying a1D). Note how the clock format only selects hours and minutes (no seconds) and the date format selects a month name, followed by one space and a two-digit day-of-month number.(Image: \"B_time2\")The lower example chooses to annotate the weekdays (by specifying a1K) while the upper example choses dates (by specifying a1D). Note how the clock format only selects hours and minutes (no seconds) and the date format selects a month name, followed by one space and a two-digit day-of-month number.The third example presents two years, annotating both the years and every 3rd month.using GMT\nbasemap(region=\"1997T/1999T/0/1\", proj=\"X12/0.25\", frame=\"pa3Of1o sa1Y S\", conf=(FORMAT_DATE_MAP=\"o\",\n    FORMAT_TIME_PRIMARY_MAP=\"Character\", FONT_ANNOT_PRIMARY=\"+9p\"), fmt=:png, show=true)Note that while the year annotation is centered on the 1-year interval, the month annotations must be centered on the corresponding month and not the 3-month interval. The FORMATDATEMAP selects month name only and FORMATTIMEPRIMARYMAP selects the 1-character, upper case abbreviation of month names using the current language (selected by GMTLANGUAGE).(Image: \"B_time3\")The fourth example only shows a few hours of a day, using relative time by specifying t in the region option while the TIME_UNIT is d (for days). We select both primary and secondary annotations, ask for a 12-hour clock, and let time go from right to left:using GMT\ngmt(\"set FORMAT_CLOCK_MAP=-hham FONT_ANNOT_PRIMARY +9p TIME_UNIT d\")\nbasemap(region=\"0.2t/0.35t/0/1\", proj=\"X-12/0.25\", frame=\"pa15mf5m sa1H S\",\n    conf=(FORMAT_CLOCK_MAP=\"-hham\", FONT_ANNOT_PRIMARY=\"+9p\", TIME_UNIT=\"d\"), fmt=:png, show=true)(Image: \"B_time4\")The fifth example shows a few weeks of time (Figure Cartesian time axis, example 5). The lower axis shows ISO weeks with week numbers and abbreviated names of the weekdays. The upper uses Gregorian weeks (which start at the day chosen by TIMEWEEKSTART); they do not have numbers.using GMT\ngmt(\"set FORMAT_DATE_MAP u FORMAT_TIME_PRIMARY_MAP Character FORMAT_TIME_SECONDARY_MAP full\n     FONT_ANNOT_PRIMARY +9p\")\nbasemap(region=\"1969-7-21T/1969-8-9T/0/1\", proj=\"X12/0.25\", frame=\"pa1K sa1U S\")\ngmt(\"set FORMAT_DATE_MAP o TIME_WEEK_START Sunday FORMAT_TIME_SECONDARY_MAP Chararacter\")\nbasemap!(frame=\"pa3Kf1k sa1r S\", y_offset=1.7, fmt=:png, show=true)(Image: \"B_time5\")Our sixth example shows the first five months of 1996, and we have annotated each month with an abbreviated, upper case name and 2-digit year. Only the primary axes information is specified.using GMT\nbasemap(region=\"1996T/1996-6T/0/1\", proj=\"X12/0.25\", frame=\"a1Of1d S\",\n    conf=(FORMAT_DATE_MAP=\"\\\"o yy\\\"\", FORMAT_TIME_PRIMARY_MAP=\"Abbreviated\"), fmt=:png, show=true)(Image: \"B_time6\")Our seventh and final example illustrates annotation of year-days. Unless we specify the formatting with a leading hyphen in FORMATDATEMAP we get 3-digit integer days. Note that in order to have the two years annotated we need to allow for the annotation of small fractional intervals; normally such truncated interval must be at least half of a full interval.using GMT\ngmt(\"set FORMAT_DATE_MAP jjj TIME_INTERVAL_FRACTION 0.05 FONT_ANNOT_PRIMARY +9p\")\nbasemap(region=\"2000-12-15T/2001-1-15T/0/1\", proj=\"X12/0.25\", frame=\"pa5Df1d sa1Y S\",\n    conf=(FORMAT_DATE_MAP=\"jjj\", TIME_INTERVAL_FRACTION=0.05, FONT_ANNOT_PRIMARY=\"+9p\"), fmt=:png, show=true)(Image: \"B_time7\")"
},

{
    "location": "frames/#Custom-axes-1",
    "page": "Draw frames examples",
    "title": "Custom axes",
    "category": "section",
    "text": "if (GMTver < 6)     T1 = [\"416.0 ig Devonian\"; \"443.7 ig Silurian\"; \"488.3 ig Ordovician\"; \"542 ig Cambrian\"];     T2 = [\"0 a\"; \"1 a\"; \"2 f\"; \"2.71828 ag e\"; \"3 f\"; \"3.1415926 ag @~p@~\"; \"4 f\"; \"5 f\"; \"6 f\";           \"6.2831852 ag 2@~p@~\"]; else     T1 = textrecord([416.0 443.7 488.3 542], [\"ig Devonian\", \"ig Silurian\", \"ig Ordovician\", \"ig Cambrian\"]);     T2 = textrecord([0 1 2 2.71828 3 3.1415926 4 5 6 6.2831852],                      [\"a\", \"a\", \"f\", \"ag e\", \"f\", \"ag @~p@~\", \"f\", \"f\", \"f\", \"ag 2@~p@~\"]); end basemap(T2,  region=\"416/542/0/6.2831852\", proj=\"X-5i/2.5i\", frame=\"WS+glightblue px25f5g25+u\\\" Ma\\\" pyc\") basemap!(T1, frame=\"WS sxc\", conf=(MAPANNOTOFFSETSECONDARY=\"10p\", MAPGRIDPENSECONDARY=\"2p\"), show=true)"
},

{
    "location": "monolitic/#",
    "page": "Monolithic",
    "title": "Monolithic",
    "category": "page",
    "text": ""
},

{
    "location": "monolitic/#Monolithic-1",
    "page": "Monolithic",
    "title": "Monolithic",
    "category": "section",
    "text": "In this mode all GMT options are put in a single text string that is passed, plus the data itself when it applies, to the gmt() command. This function is invoked with the syntax (where the brackets mean optional parameters):[output objects] = gmt(\"modulename optionstring\" [, input objects]);where modulename is a string with the name of a GMT module (e.g., surface, grdimage, psmeca, or even a custom extension), while the optionstring is a text string with the options passed to this module. If the module requires data inputs from the Julia environment, then these are provided as optional comma-separated arguments following the option string. Should the module produce output(s) then these are captured by assigning the result of gmt to one or more comma-separated variables. Some modules do not require an option string or input objects, or neither, and some modules do not produce any output objects.In addition, it can also use two i/o modules that are irrelevant on the command line: the read and write modules. These modules allow to import and export any of the GMT data types to and from external files. For instance, to import a grid from the file relief.nc we runG = gmt(\"read -Tg relief.nc\");We use the -T option to specify grid (g), image (i), PostScript (p), color palette (c), dataset (d) or textset (t). Results kept in Julia can be written out at any time via the write module, e.g., to save the grid Z to a file we usegmt(\"write model_surface.nc\", Z);Because GMT data tables often contain headers followed by many segments, each with their individual segment headers, it is best to read such data using the read module since native Julia import functions risk to choke on such headers."
},

{
    "location": "monolitic/#How-input-and-output-are-assigned-1",
    "page": "Monolithic",
    "title": "How input and output are assigned",
    "category": "section",
    "text": "Each GMT module knows what its primary input and output objects should be. Some modules only produce output (e.g., psbasemap makes a basemap plot with axes annotations) while other modules only expect input and do not return any items back (e.g., the write module writes the data object it is given to a file). Typically, (i.e., on the command line) users must carefully specify the input filenames and sometimes give these via a module option. Because users of this wrapper will want to provide input from data already in memory and likewise wish to assign results to variables, the syntax between the command line and Julia commands necessarily must differ. For example, here is a basic GMT command that reads the time-series raw_data.txt and filters it using a 15-unit full-width (6 sigma) median filter:gmt filter1d raw_data.txt –Fm15 > filtered_data.txtHere, the input file is given on the command line but input could instead come via the shell’s standard input stream via piping. Most GMT modules that write tables will write these to the shell’s output stream and users will typically redirect these streams to a file (as in our example) or pipe the output into another process. When using GMT.jl there are no shell redirections available. Instead, we wish to pass data to and from the Julia environment. If we assume that the content in raw_data.txt exists in a array named raw_data and we wish to receive the filtered result as a segment array named filtered, we would run the commandfiltered = gmt(\"filter1d -Fm15\", raw_data);This illustrates the main difference between command line and Julia usage: Instead of redirecting output to a file we return it to an internal object (here, a segment array) using standard Julia assignments of output.For data types where piping and redirection of output streams are inappropriate (including most grid file formats) the GMT modules use option flags to specify where grids should be written. Consider a GMT command that reads (x, y, z) triplets from the file depths.txt and produces an equidistant grid using a Green’s function-based spline-in-tension gridding routine:gmt greenspline depths.txt -R-50/300/200/600 -I5 -D1 -St0.3 -Gbathy.ncHere, the result of gridding Cartesian data (-D1) within the specified region (an equidistant lattice from x from -50 to 300 and y from 200 to 600, both with increments of 5) using moderately tensioned cubic splines (-St0.3) is written to the netCDF file bathy.nc. When using GMT.jl we do not want to write a file but wish to receive the resulting grid as a new Julia variable. Again, assuming we already loaded in the input data, the equivalent command isbathy = gmt(\"greenspline -R-50/300/200/600 -I5 -D1 -St0.3\", depths);Note that -G is no longer specified among the options. In this case the wrapper uses the GMT API to determine that the primary output of greenspline is a grid and that this is specified via the -G option. If no such option is given (or given without specifying a filename), then we instead return the grid via memory, provided a left-side assignment is specified. GMT only allows this behavior when called via an external API such as this wrapper: Not specifying the -G option on the command line would result in an error message. However, it is perfectly fine to specify the option -Gbathy.nc in Julia – it simply means you are saving the result to a file instead of returning it to Julia.Some GMT modules can produce more than one output (here called a secondary outputs) or can read more than one input type (i.e., secondary inputs). Secondary inputs or outputs are always specified by explicit module options on the command line, e.g., -Fpolygon.txt. In these cases, the gmt() enforces the following rules: When a secondary input is passed as an object then we must specify the corresponding option flag but provide no file argument (e.g., just -F in the above case). Likewise, for secondary output we supply the option flag and add additional objects to the left-hand side of the assignment. All secondary items, whether input or output, must appear after all primary items, and if more than one secondary item is given then their order must match the order of the corresponding options in optionstring.Here are two examples contrasting the GMT command line versus gmt() usage. In the first example we wish to determine all the data points in the file all_points.txt that happen to be located inside the polygon specified in the file polygon.txt. On the command line this would be achieved bygmt select points.txt -Fpolygon.txt > points_inside.txtwhile in Julia (assuming the points and polygon already reside in memory) we would runinside = gmt(\"gmtselect -F\", points, polygon);Here, the points object must be listed first since it is the primary data expected.Our second example considers the joining of line segments into closed polygons. We wish to create one file with all closed polygons and another file with any remaining disjointed lines. Not expecting perfection, we allow segment end-points closer than 0.1 units to be connected. On the command line we would rungmt connect all_segments.txt -Cclosed.txt -T0.1 > rest.txtwhere all_segments.txt are the input lines, closed.txt is the file that will hold closed polygons made from the relevant lines, while any remaining lines (i.e., open polygons) are written to standard output and redirected to the file rest.txt. Equivalent Julia usage would beall = gmt(\"read -Td all_segments.txt\");\nrest, closed = gmt(\"gmtconnect -T0.1 -C\", all);Note the primary output (here rest) must be listed before any secondary outputs (here closed) in the left-hand side of the assignment.So far, the gmt() function has been able to understand where inputs and outputs objects should be inserted, provided we follow the rules introduced above. However, there are two situations where more information must be provided. The first situation involves two GMT modules that allow complete freedom in how arguments are passed. These are gmtmath and grdmath, our reverse polish notation calculators for tables and grids, respectively. While the command-line versions require placement of arguments in the right order among the desired operators, the gmt() necessarily expects all inputs at the end of the function call. Hence we must assist the command by placing markers where the input arguments should be used; the marker we chose is the question mark (?). We will demonstrate this need using an example of grdmath. Imagine that we have created two separate grids: kei.nc contains an evaluation of the radial z = bei(r) Kelvin-Bessel function while cos.nc contains a cylindrical undulation in the x-direction. We create these two grids on the command line bygmt grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI = kei.nc\ngmt grdmath -R -I256+ X COS = cos.ncLater, we decide we need pi plus the product of these two grids, so we computegmt grdmath kei.nc cos.nc MUL PI ADD = answer.ncIn Julia the first two commands are straightforward:kei = gmt(\"grdmath -R-4/4/-4/4 -I256+ X Y HYPOT KEI\");\nC   = gmt(\"grdmath -R -I256+ X COS\");but when time comes to perform the final calculation we cannot simply doanswer = gmt(\"grdmath MUL PI ADD\", kei, C);since grdmath would not know where kei and C should be put in the context of the operators MUL and ADD. We could probably teach grdmath to discover the only possible solution since the MUL operator requires two operands but none are listed on the command line. The logical choice then is to take kei and C as operands. However, in the general case it may not be possible to determine a unique layout, but more importantly it is simply too confusing to separate all operators from their operands (other than constants) as we would lose track of the mathematical operation we are performing. For this reason, we will assist the module by inserting question marks where we wish the module to use the next unused input object in the list. Hence, the valid command actually becomesanswer = gmt(\"grdmath ? ? MUL PI ADD\", kei, C);Of course, all these calculations could have been done at once with no input objects but often we reuse results in different contexts and then the markers are required. The second situation arises if you wish to use a grid as argument to the -R option (i.e., to set the current region to that of the grid). On the command line this may look likegmt pscoast -Reurope.nc -JM5i –P -Baf -Gred > map.psHowever, in Julia we cannot simply supply -R with no argument since that is already an established shorthand for selecting the previously specified region. The solution is to supply –R?. Assuming our grid is called europe then the Julia command would becomemap = gmt(\"pscoast -R? -JM5i -P -Baf -Gred\", europe);"
},

{
    "location": "modules/#",
    "page": "By Modules",
    "title": "By Modules",
    "category": "page",
    "text": ""
},

{
    "location": "modules/#By-Modules-1",
    "page": "By Modules",
    "title": "By Modules",
    "category": "section",
    "text": "In this mode we access the individual GMT modules directly by their name, and options are set using keyword arguments. The general syntax is (where the brackets mean optional parameters):[output objects] = modulename([cmd::String=\"\",] [argi=[],] opt1=val1, opt2=val2, kwargs...);where modulename is the program name (e.g. coast), cmd is used to transmit a file name for modules that will read data from files and argi is one or, and for certain modules, more data arrays or GMT.jl data types. opti named arguments common to many modules used for example to set the output format. Finally kwargs are keyword parameters used to set the individual module options. But contrary to the Monolithic usage, the one letter GMT option syntax may be replaced by more verbose aliases. To make it clear let us look at couple of examples.coast(region=\"g\", proj=\"A300/30/6c\", frame=\"g\", resolution=\"c\", land=\"navy\")This command creates a map in PotScript file called GMTjl_tmp.ps and save it in your system\'s tmp directory. For comparison, the same command could have been written, using the classical one letter option syntax, as:coast(R=\"g\", J=\"A300/30/6c\", B=\"g\", D=\"c\", G=\"navy\")So, each module defines a set of aliases to the one letter options that are reported in each module man page.Before diving more in the way options may be transmitted into the module, we have to understand what happens with the output image file. By not directly specifying any format we are using the default output image format which is PostScript (actually, with the exception of grdimage -A, the only format that GMT can write). But we can select other formats by using the fmt keyword, for example fmt=\"jpg\", or fmt=:png or fmt=:pdf. In such cases, the ghostscript program (you need to have it installed) will take care of converting the ps file into the selected format. Note that we used either strings (\"\") or symbols (:) to represent the format. Here the rule is we can use symbols for any string argument that can be safely written as a symbol. Example, this is valid =:abc, but this is not =:+a (apparently parser will try to add to a). The use of symbols may be prefered for a question of lazzyness (less typing).The above example, however, does not use any input data (coast knows how to find its own data). One way of providing it to modules that work on them is to send in a file name with the data to operate on. This examplegrdimage(\"@tut_relief.nc\", shade=\"+ne0.8+a100\", proj=:M12c, frame=:a, show=true)reads a the netCDF grid tut_relief.nc and displays it as an Mercator projected image. The \'@\' prefix is used by GMT to know that the grid file should be downloaded from a server and cached locally. This example introduces also the show=true keyword. It means that we want to see right way the image that has just been created. While it might seam obvious that one want to see the result, the result might not be ready with only one GMT module call. And that\'s why the GMT philosophy uses a layer cake  model to construct potentially highly complex figures. Next example illustrates a slightly more evolved exampletopo = makecpt(color=:rainbow, range=\"1000/5000/500\", Z=[]);\ngrdimage(\"@tut_relief.nc\", shade=\"+ne0.8+a100\", proj=:M12c, frame=:a, color=topo,\n         fmt=:jpg)\ncolorbar!(position=\"jTC+w5i/0.25i+h+o0/-1i\", region=\"@tut_relief.nc\", color=topo,\n       frame=\"y+lm\", fmt=:jpg, show=true)Here we use the makecpt command to compute a colormap object and used it as the value of the color keyword of both grdimage and colorbar modules. The final image is made up of two layers, the first one is the part created by grdimage, which is complemented by the color scale plot performed by colorbar. But since this was an appending operation we HAD to use the ! form. This form tells GMT to append to a previous initiated image. The image layer cake is finalized by the show=true keyword. If our example had more layers, we would have used the same rule: second and on layers use the ! construct and the last is signaled by show=true.By default the image files are writen into tmp system directory under the name GMTjl_tmp.ps (remember PostScript is the default format) and GMTjl_tmp.xxx when user specifies a different format with the fmt keyword. It\'s one of this files that shows up when show=true is used. But we may want to save the image file permanently under a different name and location. For that use the keyword savefig=name, where name is realative or full file name.The examples above show also that we didn\'t completely get rid of the compact GMT syntax. For example the shade=\"+ne0.8+a100\" in grdimage means that we are computing the shade using a normalized a cumulative Laplace distribution and setting the Sun direction from the 100 azimuth direction. For as much we would like to simplify that, it\'s just not possible for the time being. To access the (very) high degree of control that GMT provides one need to use its full syntax. As such, readers are redirected to the main GMT documentation to learn about the fine details of those options.Setting line and symbol attributes has received, however, a set of aliases. So, instead of declaring the pen line attributes like -W0.5,blue,–, one can use the aliases lw=0.5, lc=\"blue\", ls=\"–\". An example would be:plot(collect(1:10),rand(10), lw=0.5, lc=:blue, ls=\"--\", fmt=:png, marker=:circle,\n     markeredgecolor=0, size=0.2, markerfacecolor=:red, title=\"Bla Bla\",\n     x_label=:Spoons, y_label=:Forks, show=true)This example introduces also keywords to plot symbols and set their attributes. Also shown are the parameters used to set the image\'s title and labels.But setting pen attributes like illustrated above may be complicated if one has more that one set of graphical objects (lines and polygons) that need to receive different settings. A good example of this is again provide by a coast command. Imagine that we want to plot coast lines as well as country borders with different line colors and thickness. Here we cannot simple state lw=1 because the program wouldn\'t know which of the shore line or borders this attribute applies to. The solution for this is to use tuples as values of corresponding keyword options.coast(limits=[-10 0 35 45], proj=:M12c, shore=(0.5,\"red\"), frame=:a,\n        show=1, borders=(1,(1,\"green\")))Here we used tuples to set the pen attributes, where the tuple may have 1 to 3 elements in the form (width[c|i|p]], [color], [style[c|i|p|]). The borders=(1,(1,\"green\")) option is actually a tuple-in-a-tuple because here we need also to specify the political boundary level to plot (1 = National Boundaries)."
},

{
    "location": "modules/#Specifying-the-pen-attributes-1",
    "page": "By Modules",
    "title": "Specifying the pen attributes",
    "category": "section",
    "text": "So, in summary, a pen attribute may be set in three different ways:With a text string that follows the width, color, style specs as explained in Specifying pen attributes\nBy using the lw or linewidth keyword where its value is either a number, meaning the line thickness in points, or a string like the width above; the color is set with the lc or linecolor and the value is either a number between [0 255] (meaning a gray shade) or a color name (for example \"red\"); and a ls or linestyle with the value specified as a string (example: \"- -\" plot a dashed line).\nA tuple with one to three elements: ([width], [color], [style]) where each of the elements follows the same syntax as explained in the case (2) above."
},

{
    "location": "modules/#Specifying-the-axes-1",
    "page": "By Modules",
    "title": "Specifying the axes",
    "category": "section",
    "text": "The axes are controlled by the B or frame or axes keywords. The easiest form it can have is the axes=:a, which means do an automatic annotation of the 4 map boundaries – left, bottom, right and top – axes. To annotate only the left and bottom boundaries, one would do axes=\"a WSne\" (note the space between a and WSne). For a higher level of control the user must really consult the original -B documentation.Other than setting titles and labels with a axes string we can also do it by using the keywords title, x_label and y_label.The figure limits is set with the R, region or limits  keywords. Again, the full docs for this option are explained in -R documentation. But other than the string version, the numeric form region=[xmin xmax ymin ymax] is also permitted. And when dealing with grids, even the region=mygrid.grd is a valid operation. Where mygrid.grd is a GMTgrid type. The plot() function allows a no limits setting, in which case it will default to the data\'s bounding box."
},

{
    "location": "modules/#Axes-(and-other)-configuration-1",
    "page": "By Modules",
    "title": "Axes (and other) configuration",
    "category": "section",
    "text": "There are almost 150 parameters which can be adjusted individually to modify the appearance of plots or affect the manipulation of data. When a program is run, it initializes all parameters to the GMTdefaults (see more at GMT defaults).  At times it may be desirable to temporarilly override some of those defaults. We can do that easily by using any of the keywords conf, par or params, which are recognized by all modules. Its usage follows closely the syntax described at gmt.conf but using Named Tuples. The parameter names are always given in UPPER CASE. The parameter values are case-insensitive unless otherwise noted and can be given as strings or numeric. Provide as many parameters as you want in the named tuple. Examplebasemap(...., conf=(MAP_TICK_LENGTH_PRIMARY=0.25, FORMAT_GEO_MAP=\"ddd:mm:ssF\"))"
},

{
    "location": "modules/#Specifying-the-figure-size-1",
    "page": "By Modules",
    "title": "Specifying the figure size",
    "category": "section",
    "text": "Figure sizes are automatically set to 12x8 cm for basic case of Cartesian xy plots done with the plot() function but otherwise in general they need to be user specified using the J or proj or projection keywords. See the full doc at -J documentation.  For Cartesian plots one can also use the figsize=width  or figsize=[width height] keyword, where the dimensions are in centimiters. The array form allows also set height or width to 0 to have it recomputed based on the implied scale of the other axis. Use negative sizes to reverse the direction of an axis (e.g., to have y be positive down). If neither of these forms is used, the figure width defaults to 14 cm."
},

{
    "location": "modules/#The-output-format-1",
    "page": "By Modules",
    "title": "The output format",
    "category": "section",
    "text": "It was referred above that the fmt determines the output format and that the default is PostScript. Actually the default format is choosen by the contents of the global FMT variable set at the top of the GMT.jl file. Eventually this will evolve to using an evironment variable but for the moment users will have to edit that file to set a different default format.A very interesting alternative is to set FMT=\"\", that is to not specify any image format. This will result in NOT saving any file on disk but to keep the PS figure internally stored in the program\'s memory.  In other words the figure is built and kept in memory only. This allows converting to another format directly without the use of an intermediary disk file. The conversion is performed by the psconvert GMT module that would be used like this (to convert to PDF):psconvert(in_memory=true, adjust=true, format=:f, out_name=\"myfig.pdf\")The issue with this solution, that could be implemented internally without user intervention, is that it currently only works on Windows.Another interesting alternative to a file format is the option to create RGB images with psconvert and return it to Julia as a Image type type.I = psconvert(in_memory=true, adjust=true)but again, so far on Windows only. A cool thing to develop would be the possibility to display this I image with the Images.jl package."
},

{
    "location": "modules/#Saving-data-to-disk-1",
    "page": "By Modules",
    "title": "Saving data to disk",
    "category": "section",
    "text": "As referred in the Monolithic section, we have two programs to do read and writing. Their module names are gmtread and gmtwrite. These modules allow to import and export any of the GMT data types to and from external files. For instance, to save the grid G stored into a GMTgrid type into the file relief.nc we run gmtwrite(\"relief.nc\", G)Here there is no need to inform about the type of data that we are dealing with because that can be inferred from the type of the numeric argument. There are cases, however, where we may want to save the result of a computation directly on disk instead of assigning it to a Julia variable and latter save it with gmtwrite. For computations that deal with grids that is easy. Just provide ask for an output name using the outgrid keyword, likegrdcut(G, limits=[3 9 2 8], outgrid=\"lixo.grd\");but for table data the GMT programs normally output their results to stdout so if we want to save data directly to disk (as would do the corresponding GMT shell command) we use the write or |> keywords. We can also use this mechanism to append to an existing file, but then we use the append keyword. Use together with the bo option to save as a binary file. The following converts the grid G to x,y,z triplets and save the result in an ASCII disk file.grd2xyz(G, write=\"lixo.xyz\")"
},

{
    "location": "modules/#How-inputs-are-transmitted-to-modules-1",
    "page": "By Modules",
    "title": "How inputs are transmitted to modules",
    "category": "section",
    "text": "Different modules take different number of inputs (for example grdblend accepts a variable number of grids) and some modules accept primary input and optionally a secondary input (for example the weights  option in grdtrend). The primary input(s) can be sent as text strings with the names of files to be read or as Julia variables holding the appropriate data type, and that as the first argument to the module call. Alternatively, the numeric input can be sent via the data keyword whose value can be a tuple when the expected input is composed by more than one variable. The same applies when an option is expected to receive more than one arguments (for example the three R,G,B in grdview). Examples:grdimage(G, intens=I, J=:M6i, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdimage(data=G, intens=I, J=:M6i, color=C, B=\"1 WSne\", X=:c, Y=0.5, show=1)\n\ngrdview(G, intens=:+, J=:M4i, JZ=\"2i\", p=\"145/35\", G=(Gr,Gg,Gb), B=\"af WSne\", Q=:i, show=1,)"
},

{
    "location": "types/#",
    "page": "The GMT types",
    "title": "The GMT types",
    "category": "page",
    "text": ""
},

{
    "location": "types/#The-GMT.jl-types-1",
    "page": "The GMT types",
    "title": "The GMT.jl types",
    "category": "section",
    "text": ""
},

{
    "location": "types/#Grid-type-1",
    "page": "The GMT types",
    "title": "Grid type",
    "category": "section",
    "text": "type GMTgrid                  # The type holding a local header and data of a GMT grid\n   proj4::String              # Projection string in PROJ4 syntax (Optional)\n   wkt::String                # Projection string in WKT syntax (Optional)\n   range::Array{Float64,1}    # 1x6 vector with [x_min x_max y_min y_max z_min z_max]\n   inc::Array{Float64,1}      # 1x2 vector with [x_inc y_inc]\n   registration::Int          # Registration type: 0 -> Grid registration; 1 -> Pixel registration\n   nodata::Float64            # The value of nodata\n   title::String              # Title (Optional)\n   comment::String            # Remark (Optional)\n   command::String            # Command used to create the grid (Optional)\n   datatype::String           # \'float\' or \'double\'\n   x::Array{Float64,1}        # [1 x n_columns] vector with XX coordinates\n   y::Array{Float64,1}        # [1 x n_rows]    vector with YY coordinates\n   z::Array{Float32,2}        # [n_rows x n_columns] grid array\n   x_units::String            # Units of XX axis (Optional)\n   y_units::String            # Units of YY axis (Optional)\n   z_units::String            # Units of ZZ axis (Optional)\n   layout::String             # A three character string describing the grid memory layout\nend"
},

{
    "location": "types/#Image-type-1",
    "page": "The GMT types",
    "title": "Image type",
    "category": "section",
    "text": "type GMTimage                 # The type holding a local header and data of a GMT image\n   proj4::String              # Projection string in PROJ4 syntax (Optional)\n   wkt::String                # Projection string in WKT syntax (Optional)\n   range::Array{Float64,1}    # 1x6 vector with [x_min x_max y_min y_max z_min z_max]\n   inc::Array{Float64,1}      # 1x2 vector with [x_inc y_inc]\n   registration::Int          # Registration type: 0 -> Grid registration; 1 -> Pixel registration\n   nodata::Float64            # The value of nodata\n   title::String              # Title (Optional)\n   comment::String            # Remark (Optional)\n   command::String            # Command used to create the image (Optional)\n   datatype::String           # \'uint8\' or \'int8\' (needs checking)\n   x::Array{Float64,1}        # [1 x n_columns] vector with XX coordinates\n   y::Array{Float64,1}        # [1 x n_rows]    vector with YY coordinates\n   image::Array{UInt8,3}      # [n_rows x n_columns x n_bands] image array\n   x_units::String            # Units of XX axis (Optional)\n   y_units::String            # Units of YY axis (Optional)\n   z_units::String            # Units of ZZ axis (Optional) ==> MAKES NO SENSE\n   colormap::Array{Clong,1}   # \n   alpha::Array{UInt8,2}      # A [n_rows x n_columns] alpha array\n   layout::String             # A four character string describing the image memory layout\nend"
},

{
    "location": "types/#Dataset-type-1",
    "page": "The GMT types",
    "title": "Dataset type",
    "category": "section",
    "text": "type GMTdataset\n    data::Array{Float64,2}     # Mx2 Matrix with segment data\n    text::Array{Any,1}         # Array with text after data coordinates (mandatory only when plotting Text)\n    header::String             # String with segment header (Optional but sometimes very useful)\n    comment::Array{Any,1}      # Array with any dataset comments [empty after first segment]\n    proj4::String              # Projection string in PROJ4 syntax (Optional)\n    wkt::String                # Projection string in WKT syntax (Optional)\nend"
},

{
    "location": "types/#CPT-type-1",
    "page": "The GMT types",
    "title": "CPT type",
    "category": "section",
    "text": "type GMTcpt\n    colormap::Array{Float64,2}\n    alpha::Array{Float64,1}\n    range::Array{Float64,2}\n    minmax::Array{Float64,1}\n    bfn::Array{Float64,2}\n    depth::Cint\n    hinge::Cdouble\n    cpt::Array{Float64,2}\n    model::String\n    comment::Array{Any,1}   # Cell array with any comments\nend"
},

{
    "location": "types/#Postscript-type-1",
    "page": "The GMT types",
    "title": "Postscript type",
    "category": "section",
    "text": "type GMTps\n    postscript::String      # Actual PS plot (text string)\n    length::Int             # Byte length of postscript\n    mode::Int               # 1 = Has header, 2 = Has trailer, 3 = Has both\n    comment::Array{Any,1}   # Cell array with any comments\nend"
},

{
    "location": "#",
    "page": "Index",
    "title": "Index",
    "category": "page",
    "text": ""
},

{
    "location": "#Index-1",
    "page": "Index",
    "title": "Index",
    "category": "section",
    "text": ""
},

{
    "location": "#GMT.basemap",
    "page": "Index",
    "title": "GMT.basemap",
    "category": "function",
    "text": "basemap(cmd0::String=\"\"; kwargs...)\n\nPlot base maps and frames.\n\nFull option list at psbasemap\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nA : polygon : – Str or [] –\nNo plotting is performed. Instead, we determine the geographical coordinates of the polygon   outline for the (possibly oblique) rectangular map domain.    -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nD : inset : – Str –\nDraw a simple map insert box on the map. Requires -F.   -D\nF : box : – Str –\nWithout further options, draws a rectangular border around any map insert (D), map scale (L)   or map rose (T)   -F\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nL : map_scale : – Str –\nDraw a map scale.   -L\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nTd : rose` : – Str –\nDraws a map directional rose on the map at the location defined by the reference and anchor points.   -Td\nTm : compass : – Str –\nDraws a map magnetic rose on the map at the location defined by the reference and anchor points.   -Tm\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.blockmean",
    "page": "Index",
    "title": "GMT.blockmean",
    "category": "function",
    "text": "blockmean(cmd0::String=\"\", arg1=[]; kwargs...)\n\nBlock average (x,y,z) data tables by L2 norm.\n\nFull option list at blockmean\n\nParameters\n\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nI : inc : – Str or Number –\nx_inc [and optionally y_inc] is the grid spacing.   -I\nA : fields : – Str –\nSelect which fields to write to individual grids. Append comma-separated codes for available   fields: z (the mean data z, but see -S), s (standard deviation), l (lowest value),   h (highest value) and w (the output weight; requires -W). [Default is just z].   -A\nC : center : – Bool –\nUse the center of the block as the output location [Default uses the mean location]. Not used when -A   -C\nE : extend : – Str or [] –\nProvide Extended report which includes s (the standard deviation about the mean), l, the lowest   value, and h, the high value for each block. Output order becomes x,y,z,s,l,h[,w]. [Default   outputs x,y,z[,w]. See -W for w output. If -Ep is used we assume weights are 1/(sigma squared)   and s becomes the propagated error of the mean.   -E\nG : grid : – Str or [] –\nWrite one or more fields directly to grids on disk; no table data are return. If more than one   fields are specified via A then grdfile must contain the format flag %s so that we can embed the   field code in the file names. If not provided but A is used, return 1 or more GMTgrid type(s).   -G\nS : npts : numberofpoints – Str or [] –  \nUse S=:n to report the number of points inside each block, S=:s to report the sum of all z-values    inside a block, S=:w to report the sum of weights [Default (or S=:m reports mean value].   -S\nW : weights : – Str or [] –\nUnweighted input and output have 3 columns x,y,z; Weighted i/o has 4 columns x,y,z,w. Weights can   be used in input to construct weighted mean values for each block.   -W\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.blockmedian",
    "page": "Index",
    "title": "GMT.blockmedian",
    "category": "function",
    "text": "blockmedian(cmd0::String=\"\", arg1=[]; kwargs...)\n\nBlock average (x,y,z) data tables by L1 norm.\n\nFull option list at blockmedian\n\n\n\n\n\n"
},

{
    "location": "#GMT.blockmode",
    "page": "Index",
    "title": "GMT.blockmode",
    "category": "function",
    "text": "blockmode(cmd0::String=\"\", arg1=[]; kwargs...)\n\nBlock average (x,y,z) data tables by mode estimation.\n\nFull option list at blockmode\n\n\n\n\n\n"
},

{
    "location": "#GMT.clip",
    "page": "Index",
    "title": "GMT.clip",
    "category": "function",
    "text": "clip(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads (length,azimuth) pairs from file and plot a windclip diagram.\n\nFull option list at psclip\n\nParameters\n\nC : endclippath : – Bool or [] –\nMark end of existing clip path. No input file is needed.   -C\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nA : inc : – Str or [] –\nBy default, geographic line segments are connected as great circle arcs. To connect them as straight lines, use A \n\n[`-A`](http://gmt.soest.hawaii.edu/doc/latest/psclip.html#A)\n\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nN : invert : – Bool or [] –\nInvert the sense of the test, i.e., clip regions where there is data coverage.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nT : clipmapregion : – Bool or [] –\nRather than read any input files, simply turn on clipping for the current map region.\n\n[`-T`](http://gmt.soest.hawaii.edu/doc/latest/psclip.html#t)\n\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.coast",
    "page": "Index",
    "title": "GMT.coast",
    "category": "function",
    "text": "coast(cmd0::String=\"\"; clip=[], kwargs...)\n\nPlot continents, shorelines, rivers, and borders on maps. Plots grayshaded, colored, or textured land-masses [or water-masses] on maps and [optionally] draws coastlines, rivers, and political boundaries. A map projection must be supplied.\n\nFull option list at pscoast\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nA : area : – Str or Number –\nFeatures with an area smaller than minarea in km^2 or of   hierarchical level that is lower than minlevel or higher than   max_level will not be plotted.   -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : river_fill : – Str –\nSet the shade, color, or pattern for lakes and river-lakes.   -C\nD : res : resolution : – Str –		Flags = c|l|i|h|f|a\nSelects the resolution of the data set to use ((f)ull, (h)igh, (i)ntermediate, (l)ow, (c)rude), or (a)uto).   -D\nE : DCW : – Str –\nSelect painting or dumping country polygons from the Digital Chart of the World.   -E\nTuple(\"code\", Str); Tuple(\"code\" [,\"fill\"], (pen)); Tuple((...),(...),...)\nex: (\"PT\",(0.5,\"red\",\"–\")); ((\"PT\",\"gblue\",(0.5,\"red\"),(\"ES\",(0.5,\"yellow\")))\nF : box : – Str –\nDraws a rectangular border around the map scale or rose.   -F\nG : land : – Str –\nSelect filling or clipping of “dry” areas.   -G\nI : rivers : – Str –\nDraw rivers. Specify the type of rivers and [optionally] append pen attributes.   -I\nL : map_scale : – Str –\nDraw a map scale.   -L\nM : dump : – Str –\nDumps a single multisegment ASCII output. No plotting occurs.   -M\nN : borders : – Str –\nDraw political boundaries. Specify the type of boundary and [optionally] append pen attributes   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nclip : – Str –		Flags = land|water|end\nTo clip land do clip=:land, clip=:water clips water. Use end to mark end of existing clip path.   No projection information is needed.   -Q\nS : water : – Str –\nSelect filling or clipping of “wet” areas.   -S\nTd : rose` : – Str –\nDraws a map directional rose on the map at the location defined by the reference and anchor points.   -Td\nTm : compass : – Str –\nDraws a map magnetic rose on the map at the location defined by the reference and anchor points.   -Tm\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nW : shore : – Str –   Draw shorelines [Default is no shorelines]. Append pen attributes.   -W\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.colorbar",
    "page": "Index",
    "title": "GMT.colorbar",
    "category": "function",
    "text": "colorbar(cmd0::String=\"\", arg1=[]; kwargs...)\n\nPlots gray scales or color scales on maps.\n\nFull option list at psscale\n\nD : position : – Str –\nDefines the reference point on the map for the color scale using one of four coordinate systems.   -D\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nF : box : – Str –\nDraws a rectangular border around the scale.   -F\nG : truncate : – Str –  \nTruncate the incoming CPT so that the lowest and highest z-levels are to zlo and zhi.   -G\nI : shade : – Number or [] –  \nAdd illumination effects.   -I\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nL : equal_size : – Str or [] –\nGives equal-sized color rectangles. Default scales rectangles according to the z-range in the CPT.   -L\nM : monochrome : – Bool or [] –\nForce conversion to monochrome image using the (television) YIQ transformation.   -M\nN : dpi : – Str or number –\nControls how the color scale is represented by the PostScript language.   -N\nQ : log : – Str –\nSelects a logarithmic interpolation scheme [Default is linear].   -Q\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nS : nolines : – Bool or [] –\nDo not separate different color intervals with black grid lines.\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nW : zscale : – Number –\nMultiply all z-values in the CPT by the provided scale.   -W\nZ : zfile : – Str –\nFile with colorbar-width per color entry.   -Z\n\n\n\n\n\n"
},

{
    "location": "#GMT.gmtinfo",
    "page": "Index",
    "title": "GMT.gmtinfo",
    "category": "function",
    "text": "gmtinfo(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads files and finds the extreme values in each of the columns.\n\nFull option list at gmtinfo\n\nParameters\n\nA : – Str –\nSpecify how the range should be reported.   -A\nC : per_column : – Bool or [] –\nReport the min/max values per column in separate columns [Default uses <min/max> format].   -C\nD : center : – Bool or [] –  \nModifies results obtained by -I by shifting the region to better align with the center of the data.   -D\nE : get_record : – Str or [] –\nReturns the record whose column col contains the minimum (l) or maximum (h) value.    -E\nF : counts : – Str or [] –\nReturns the counts of various records depending on the appended mode.   -F\nI : report_region : – Number or Str –\nReport the min/max of the first n columns to the nearest multiple of the provided increments   and output results in the form -Rw/e/s/n    -I\nL : common_limits : – Bool or [] –\nDetermines common limits across tables or segments.   -L\nS : forerrorbars : – Str or [] –\nAdd extra space for error bars. Useful together with I option and when later plotting with psxy E.   -S\nT : nearest_multiple : – Number or Str –\nReport the min/max of the first (0’th) column to the nearest multiple of dz and output this as   the string -Tzmin/zmax/dz.   -T\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nwrite : |> : Str –     Flags = fname\nSave result to ASCII file instead of returning to a Julia variable. Give file name as argument.   Use the bo option to save as a binary file.\nappend : Str –     Flags = fname\nAppend result to an existing file named fname instead of returning to a Julia variable.   Use the bo option to save as a binary file.\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\no : output_col : – Str –     Flags = cols\nSelect specific data columns for primary output, in arbitrary order.   -o\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.logo",
    "page": "Index",
    "title": "GMT.logo",
    "category": "function",
    "text": "logo(cmd0::String=\"\"; kwargs...)\n\nPlots the GMT logo on a map. By default, the GMT logo is 5 cm wide and 2.5 cm high and will be positioned relative to the current plot origin. Use various options to change this and to place a transparent or opaque rectangular map panel behind the GMT logo.\n\nFull option list at gmtlogo\n\nParameters\n\nD : pos : position : – Str –\nSets reference point on the map for the image using one of four coordinate systems.   -D\nF : box : – Str –\nWithout further options, draws a rectangular border around the GMT logo using MAPFRAMEPEN.   or map rose (T)   -F\njulia : – Number –\nCreate the Julia instead of the GMT logo. Provide circle diameter in centimeters\nGMTjulia : – Number –\nCreate the GMT Julia GMT logo. Provide circle diameter in centimeters\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nExample, make a GMT Julia logo with circles of 1 cm: logo(GMTjulia=1, show=true)\n\n\n\n\n\n"
},

{
    "location": "#GMT.gmtwrite-Tuple{String,Any}",
    "page": "Index",
    "title": "GMT.gmtwrite",
    "category": "method",
    "text": "gmtwrite(fname::String, data; kwargs...)\n\nWrite a GMT object to file. The object is one of \"grid\" or \"grd\", \"image\" or \"img\", \"dataset\" or \"table\", \"cmap\" or \"cpt\" and \"ps\" (for postscript).\n\nWhen saving grids we have a large panoply of formats at our disposal.\n\nParameters\n\nid : – Str –  \nUse an id code when not not saving a grid into a standard COARDS-compliant netCDF grid. This id   is made up of two characters like ef to save in ESRI Arc/Info ASCII Grid Interchange format (ASCII float).   See the full list of ids at https://gmt.soest.hawaii.edu/doc/latest/grdconvert.html#format-identifier.\n-G\nscale : offset – Number –\nYou may optionally ask to scale the data and then offset them with the specified amounts.   These modifiers are particularly practical when storing the data as integers, by first removing an offset   and then scaling down the values.\nnan : novalue : invalid : missing – Number –\nLets you supply a value that represents an invalid grid entry, i.e., ‘Not-a-Number’.\ngdal : – Bool or [] –\nForce the use of the GDAL library to write the grid (to be used only with grids).   \ndriver : – Str –  \nWhen saving in other than the netCDF format we must tell the GDAL library what is wished format.   That is done by specifying the driver name used by GDAL itself (e.g., netCDF, GTiFF, etc...).\ndatatype : – Str –  		Flags = u8|u16|i16|u32|i32|float32\nWhen saving with GDAL we can specify the data type from u8|u16|i16|u32|i32|float32 where ‘i’ and ‘u’ denote   signed and unsigned integers respectively.\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\n\nExample: write the GMTgrid \'G\' object into a nc file called \'lixo.grd\'\n\ngmtwrite(\"lixo.grd\", G);\n\n\n\n\n\n"
},

{
    "location": "#GMT.grdcontour",
    "page": "Index",
    "title": "GMT.grdcontour",
    "category": "function",
    "text": "grdcontour(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads a 2-D grid file or a GMTgrid type and produces a contour map by tracing each contour through the grid.\n\nFull option list at pscontour\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nA : annot : – Str or Number –       Flags = [-|[+]annot_int][labelinfo]\nannot_int is annotation interval in data units; it is ignored if contour levels are given in a file.   -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : cont : contours : levels : – Str or Number –\nContours to be drawn.   -C\nD : dump : – Str –\nDump contours as data line segments; no plotting takes place.   -D\nF : force : – Str or [] –\nForce dumped contours to be oriented so that higher z-values are to the left (-Fl [Default]) or right.   -F\nG : labels : – Str –\nControls the placement of labels along the quoted lines.   -G\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nL : range : – Str –\nLimit range: Do not draw contours for data values below low or above high.   -L\nN : fill : – Bool or [] –\nFill the area between contours using the discrete color table given by cpt.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : cut : – Str or Number –\nDo not draw contours with less than cut number of points.   -Q\nS : smooth : – Number –\nUsed to resample the contour lines at roughly every (gridbox_size/smoothfactor) interval.   -S\nT : ticks : – Str –\nDraw tick marks pointing in the downward direction every gap along the innermost closed contours.   -T\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nW : pen : – Str or Number –\nSets the attributes for the particular line.   -W\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nZ : scale : – Str –\nUse to subtract shift from the data and multiply the results by factor before contouring starts.   -Z\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\ndo : nodata_out : – Str or Number –     Flags = nodata\nExamine all output columns and if any item equals NAN substitute it with   the chosen missing data value.   -do\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.grdimage",
    "page": "Index",
    "title": "GMT.grdimage",
    "category": "function",
    "text": "grdimage(cmd0::String=\"\", arg1=[], arg2=[], arg3=[]; kwargs...)\n\nProduces a gray-shaded (or colored) map by plotting rectangles centered on each grid node and assigning them a gray-shade (or color) based on the z-value.\n\nFull option list at grdimage\n\nParameters\n\nA : img_out : image_out : – Str –\nSave an image in a raster format instead of PostScript.   -A\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nD : img_in : image_in : – Str or [] –\nSpecifies that the grid supplied is an image file to be read via GDAL.   -D\nE : dpi : – Int or [] –  \nSets the resolution of the projected grid that will be created.   -E\nG : – Str or Int –\n-G\nI : shade : intensity : intensfile : – Str or GMTgrid –\nGives the name of a grid file or GMTgrid with intensities in the (-1,+1) range,   or a grdgradient shading flags.   -I\nM : monochrome : – Bool or [] –\nForce conversion to monochrome image using the (television) YIQ transformation.   -M\nN : noclip : – Bool or [] –\nDo not clip the image at the map boundary.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : nan_t : nan_alpha : – Bool or [] –\nMake grid nodes with z = NaN transparent, using the colormasking feature in PostScript Level 3.\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nn : interp : – Str –         Flags = bcln+a+bBC+c+tthreshold\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation,   l for bilinear interpolation, or n for nearest-neighbor value.   -n\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.grdinfo",
    "page": "Index",
    "title": "GMT.grdinfo",
    "category": "function",
    "text": "grdinfo(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads a 2-D grid file and reports metadata and various statistics for the (x,y,z) data in the grid file\n\nFull option list at grdinfo\n\nParameters\n\nC : numeric : – Str or Number –\nFormats the report using tab-separated fields on a single line.   -C\nD : tiles : – Number or Str –  \nDivide a single grid’s domain (or the -R domain, if no grid given) into tiles of size   dx times dy (set via -I).   -D\nF : – Bool or [] –\nReport grid domain and x/y-increments in world mapping format.   -F\nI : nearest_multiple : – Number or Str –\nReport the min/max of the region to the nearest multiple of dx and dy, and output   this in the form -Rw/e/s/n    -I\nL : force_scan : – Number or Str –\nReport stats after actually scanning the data.   -L\nM : zmin_max : – Bool or [] –\nFind and report the location of min/max z-values.   -M\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nT : nan_t : – Number or Str –   Determine min and max z-value.   -T\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\n\n\n\n\n\n"
},

{
    "location": "#GMT.grdtrack",
    "page": "Index",
    "title": "GMT.grdtrack",
    "category": "function",
    "text": "grdtrack(cmd0::String=\"\", arg1=[], arg2=[]; kwargs...)\n\nInterpolates the grid(s) at the positions in the table and writes out the table with the interpolated values added as (one or more) new columns.\n\nFull option list at grdtrack\n\nParameters\n\nA : interp_path : – Str –\n-A\nC : equi : – Str –\n-C\nD : dfile : – Str –  \n-D\nE : by_coord : – Str –\n-E\nG : grid : – Str or GMTgrid or Tuple(GMTgrid\'s) –\n-G\nN : no_skip : – Bool or [] –\n-N\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nS : stack : – Str –\n-S\nT : radius : – Number, Str or [] –\n-T\nZ : z_only : – Bool or [] –\n-Z\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nn : interp : – Str –         Flags = bcln+a+bBC+c+tthreshold\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation,   l for bilinear interpolation, or n for nearest-neighbor value.   -n\no : output_col : – Str –     Flags = cols\nSelect specific data columns for primary output, in arbitrary order.   -o\ns : skip_col : – Str –       Flags = colsar\nSuppress output for records whose z-value equals NaN.   -s\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\nWhen using two numeric inputs and no G option, the order of the x,y and grid is not important. That is, both of this will work: D = grdtrack([0 0], G);  or  D = grdtrack(G, [0 0]); \n\n\n\n\n\n"
},

{
    "location": "#GMT.grdtrend",
    "page": "Index",
    "title": "GMT.grdtrend",
    "category": "function",
    "text": "grdtrend(cmd0::String=\"\", arg1=[], arg2=[]; kwargs...)\n\nreads a 2-D grid file and fits a low-order polynomial trend to these data by [optionally weighted] least-squares.\n\nFull option list at grdtrend\n\nParameters\n\nN : model : – Str or Number –\nSets the number of model parameters to fit.   -N\nD : diff : – Str or [] –\nCompute the difference (input data - trend). Optionaly provide a file name to save result on disk.   -D\nT : trend : – Str or [] –\nCompute the trend surface. Optionaly provide a file name to save result on disk.   -T\nW : weights : – Str –\nIf weight.nc exists, it will be read and used to solve a weighted least-squares problem.   -W\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\n\n\n\n\n\n"
},

{
    "location": "#GMT.grdview",
    "page": "Index",
    "title": "GMT.grdview",
    "category": "function",
    "text": "grdview(cmd0::String=\"\", arg1=[], arg2=[], arg3=[]; kwargs...)\n\nReads a 2-D grid file and produces a 3-D perspective plot by drawing a mesh, painting a colored/grayshaded surface made up of polygons, or by scanline conversion of these polygons to a raster image.\n\nFull option list at grdview\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nG : drapefile : – Str or GMTgrid or a Tuple with 3 GMTgrid types –\nDrape the image in drapefile on top of the relief provided by relief_file.   -G\nI : shade : intensity : intensfileintens : – Str or GMTgrid –\nGives the name of a grid file or GMTgrid with intensities in the (-1,+1) range,   or a grdgradient shading flags.   -I\nN : plane : – Str or Int –\nDraws a plane at this z-level.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : type : – Str or Int –\nSpecify m for mesh plot, s* for surface, **i for image.   -Q\nS : smooth : – Number –\nSmooth the contours before plotting.   -S\nT : no_interp : – Str –\nPlot image without any interpolation.   -T\nW : contour : mesh : facade : – Str –\nDraw contour, mesh or facade. Append pen attributes.   -W\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nn : interp : – Str –         Flags = bcln+a+bBC+c+tthreshold\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation,   l for bilinear interpolation, or n for nearest-neighbor value.   -n\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.greenspline",
    "page": "Index",
    "title": "GMT.greenspline",
    "category": "function",
    "text": "greenspline(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads randomly-spaced (x,y,z) triples and produces a binary grid file of gridded values z(x,y) by solving:\n\n	(1 - T) * L (L (z)) + T * L (z) = 0\n\nFull option list at greenspline\n\nParameters\n\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nI : inc : – Str or Number –\nx_inc [and optionally y_inc] is the grid spacing.   -I\nA : gradient : – Str –		Flags = gradfile+f12345\nThe solution will partly be constrained by surface gradients v = v*n, where v is the   gradient magnitude and n its unit vector direction.   -A\nC : approx : approximate : – Str or Number –	Flags = nvalue+ffile\nFind an approximate surface fit: Solve the linear system for the spline coefficients by   SVD and eliminate the contribution from all eigenvalues whose ratio to the largest   eigenvalue is less than value.   -C\nG : grid : – Str or [] –\nOutput grid file name. Note that this is optional and to be used only when saving   the result directly on disk. Otherwise, just use the G = greenspline(....) form.   -G\nD : mode : – Number –\nSets the distance flag that determines how we calculate distances between data points.   -D\nE : misfit : – Str or [] –		Flags = misfitfile\nEvaluate the spline exactly at the input data locations and report statistics of   the misfit (mean, standard deviation, and rms).   -E\nL : leave_trend : – Bool or [] –\nDo not remove a linear (1-D) or planer (2-D) trend when -D selects mode 0-3.   -L\nN : nodes : – Number –			Flags = nodefile\nASCII file with coordinates of desired output locations x in the first column(s).   -N\nQ : dir_derivative : – Str –		Flags = azxyz\nRather than evaluate the surface, take the directional derivative in the az azimuth and   return the magnitude of this derivative instead.   -Q\nS : splines : – Str –				Flags = ctlrpqpars\nSelect one of six different splines. The first two are used for 1-D, 2-D, or 3-D Cartesian splines.   -S\nT : mask : – Str –					Flags = maskgrid\nFor 2-D interpolation only. Only evaluate the solution at the nodes in the maskgrid that are   not equal to NaN.   -T\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nW : uncertainties : – Str or [] –	Flags = w\n\nData one-sigma uncertainties are provided in the last column. We then compute weights that\nare inversely proportional to the uncertainties squared.\n[`-W`](http://gmt.soest.hawaii.edu/doc/latest/greenspline.html#w)\n\nb : binary : – Str –\n-b\nd : nodata : – Str or Number –		Flags = ionodata\nControl how user-coded missing data values are translated to official NaN values in GMT.   -d\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\no : output_col : – Str –     Flags = cols\nSelect specific data columns for primary output, in arbitrary order.   -o\nx : n_threads : – Str or Number –  Flags = -n\nLimit the number of cores to be used in any OpenMP-enabled multi-threaded algorithms.   -x\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.histogram",
    "page": "Index",
    "title": "GMT.histogram",
    "category": "function",
    "text": "histogram(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads file and examines the first data column to calculate histogram parameters based on the bin-width provided.\n\nFull option list at pshistogram\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nW : bin : width : – Number or Str –\nSets the bin width used for histogram calculations.   -W\nA : horizontal : – Bool or [] –\nPlot the histogram horizontally from x = 0 [Default is vertically from y = 0].   -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : – Str or GMTcpt –\nGive a CPT. The mid x-value for each bar is used to look-up the bar color.   -C\nD : annot : annotate : – Str or [] –\nAnnotate each bar with the count it represents.   -D\nF : center : – Bool or [] –\nCenter bin on each value. [Default is left edge].   -F\nG : fill : – Number or Str –\nSelect filling of bars [if no G, L or C set G=100].   -G\nI : inquire : – Bool or [] –\nInquire about min/max x and y after binning.   -I\nL : labels : – Str or [] –\nDraw bar outline using the specified pen thickness [if no G, L or C set L=0.5].   -L\nN : normal : – Str –\nDraw the equivalent normal distribution; append desired pen [0.5p,black].   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : alpha : – Number or [] –\nSets the confidence level used to determine if the mean resultant is significant.   -Q\nR : region : – Str –\nSpecifies the ‘region’ of interest in (r,azimuth) space. r0 is 0, r1 is max length in units.   -R\nS : stairs : – Str or number –\nDraws a stairs-step diagram which does not include the internal bars of the default histogram.   -S\nZ : kind : – Number or Str –\nChoose between 6 types of histograms.   -Z\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.imshow-Tuple{Any}",
    "page": "Index",
    "title": "GMT.imshow",
    "category": "method",
    "text": "imshow(arg1; kw...)\n\nIs a simple front end to the grdimage program that accepts GMTgrid, GMTimage, 2D array  of floats or strings with file names of grids or images. The normal options of the grdimage program also apply here but some clever guessing of suitable necessary parameters is done if they are not provided. Contrary to other image producing modules the \"show\' keyword is not necessary to display the image. Here it is set by default. If user wants to use imshow to create layers of a more complex fig he can use show=false for the intermediate layers.\n\nExamples\n\n# Plot vertical shaded illuminated view of the Mexican hat\njulia> G = gmt(\"grdmath -R-15/15/-15/15 -I0.3 X Y HYPOT DUP 2 MUL PI MUL 8 DIV COS EXCH NEG 10 DIV EXP MUL =\");\njulia> imshow(G, frame=\"a\", shade=\"+a45\")\n\n# Plot a random heat map\njulia> imshow(rand(128,128))\n\n# Display a web downloaded jpeg image wrapped into a sinusoidal projection\njulia> imshow(\"http://larryfire.files.wordpress.com/2009/07/untooned_jessicarabbit.jpg\", region=\"d\", frame=\"g\", proj=\"I15\", img_in=\"r\", fmt=\"jpg\") \n\nSee also: grdimage\n\n\n\n\n\n"
},

{
    "location": "#GMT.makecpt",
    "page": "Index",
    "title": "GMT.makecpt",
    "category": "function",
    "text": "makecpt(cmd0::String=\"\", arg1=[]; kwargs...)\n\nMake static color palette tables (CPTs).\n\nFull option list at makecpt\n\nA : alpha : transparency : – Str –\nSets a constant level of transparency (0-100) for all color slices.   -A\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nD : – Str or [] –			Flags = [i|o]\nSelect the back- and foreground colors to match the colors for lowest and highest   z-values in the output CPT.    -D\nE : data_levels : – Int or [] –		Flags = [nlevels]\nImplies reading data table(s) from file or arrays. We use the last data column to   determine the data range   -E\nF : force_rgb : – Str or [] –		Flags = [R|r|h|c][+c]]\nForce output CPT to written with r/g/b codes, gray-scale values or color name.   -F\nG : truncate : – Str –              Flags = zlo/zhi\nTruncate the incoming CPT so that the lowest and highest z-levels are to zlo and zhi.   -G\nI : inverse : reverse : – Str –	Flags = [c][z]\nReverse the sense of color progression in the master CPT.   -I\nM : overrule_bg – Bool or [] –\nOverrule background, foreground, and NaN colors specified in the master CPT with the values of   the parameters COLORBACKGROUND, COLORFOREGROUND, and COLOR_NAN.   -M\nN : no_bg – Bool or [] –\nDo not write out the background, foreground, and NaN-color fields.\nQ : log : – Bool or [] or Str –			Flags = [i|o]\nSelects a logarithmic interpolation scheme [Default is linear].   -Q\nS : auto : – Bool or [] or Str –			Flags = [mode]\nDetermine a suitable range for the -T option from the input table(s) (or stdin).   -S\nT : range : – Str –			Flags = [min/max/inc[+b|l|n]|file|list]\nDefines the range of the new CPT by giving the lowest and highest z-value and interval.   -T\nW : wrap : categorical : – Bool or Str or [] –      Flags = [w]\nDo not interpolate the input color table but pick the output colors starting at the   beginning of the color table, until colors for all intervals are assigned.   -W\nZ : continuous : – Bool or [] –\nCreates a continuous CPT [Default is discontinuous, i.e., constant colors for each interval].   -Z\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\n\n\n\n\n\n"
},

{
    "location": "#GMT.nearneighbor",
    "page": "Index",
    "title": "GMT.nearneighbor",
    "category": "function",
    "text": "nearneighbor(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads arbitrarily located (x,y,z[,w]) triples [quadruplets] and uses a nearest neighbor algorithm to assign an average value to each node that have one or more points within a radius centered on the node. The average value is computed as a weighted mean of the nearest point from each sector inside the search radius. The weighting function used is w(r) = 1 / (1 + d ^ 2), where d = 3 * r / search_radius and r is distance from the node. This weight is modulated by the weights of the observation points [if supplied].\n\nFull option list at nearneighbor\n\nParameters\n\nI : inc : – Str or Number –\nx_inc [and optionally y_inc] is the grid spacing.   -I\nN : sectors : – Number or Str –\nThe circular area centered on each node is divided into sectors sectors.   -N\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nS : search_radius : – Number –  \nSets the search_radius that determines which data points are considered close to a node.   -S\nE : empty : – Bool or [] –\nSet the value assigned to empty nodes when G is set [NaN].   -E\nG : outgrid : – Str –\nOutput grid file name. Note that this is optional and to be used only when saving   the result directly on disk. Otherwise, just use the G = nearneighbor(....) form.   -G\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nW : weights : – Bool or [] –\nInput data have a 4th column containing observation point weights.   -W\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nn : interp : – Str –         Flags = bcln+a+bBC+c+tthreshold\nSelect grid interpolation mode by adding b for B-spline smoothing, c for bicubic interpolation,   l for bilinear interpolation, or n for nearest-neighbor value.   -n\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.plot-Tuple{Array}",
    "page": "Index",
    "title": "GMT.plot",
    "category": "method",
    "text": "plot(arg1::Array; kwargs...)\n\nreads (x,y) pairs from files [or standard input] and generates PostScript code that will plot lines, polygons, or symbols at those locations on a map.\n\nFull option list at psxy\n\nParameters\n\nA : straight_lines : – Str –  \n\nBy default, geographic line segments are drawn as great circle arcs.\nTo draw them as straight lines, use the -A flag.\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : – Str –\nGive a CPT or specify -Ccolor1,color2[,color3,...] to build a linear continuous CPT from those colors automatically.\n\n[`-C`](http://gmt.soest.hawaii.edu/doc/latest/psxy.html#c)\n\nD : offset : – Str –\nOffset the plot symbol or line locations by the given amounts dx/dy.\nE : error_bars : – Str –\nDraw symmetrical error bars.   -E\nF : conn : connection : – Str –\nAlter the way points are connected   -F\nG : fill : markerfacecolor : MarkerFaceColor : – Str –\nSelect color or pattern for filling of symbols or polygons. BUT WARN: the alias \'fill\' will set the   color of polygons OR symbols but not the two together. If your plot has polygons and symbols, use   \'fill\' for the polygons and \'markerfacecolor\' for filling the symbols. Same applyies for W bellow   -G\nI : intens : – Str or number –\nUse the supplied intens value (in the [-1 1] range) to modulate the fill color by simulating illumination.\nL : closed_polygon : – Str –\nForce closed polygons.    -L\nN : no_clip : –- Str or [] –\nDo NOT clip symbols that fall outside map border \nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nS : symbol : marker : Marker : – Str –\nPlot symbols (including vectors, pie slices, fronts, decorated or quoted lines).    -S   Alternatively select a sub-set of symbols using the aliases: marker or Marker and values:\n-, x_dash\n+, plus\na, *, star\nc, circle\nd, diamond\ng, octagon\nh, hexagon\ni, v, inverted_tri\nn, pentagon\np, ., point\nr, rectangle\ns, square\nt, ^, triangle\nx, cross\ny, y_dash\nW : line_attribs : markeredgecolor : MarkerEdgeColor : – Str –   Set pen attributes for lines or the outline of symbols   -W   WARNING: the pen attributes will set the pen of polygons OR symbols but not the two together.   If your plot has polygons and symbols, use W or line_attribs for the polygons and   markeredgecolor or MarkerEdgeColor for filling the symbols. Similar to S above.\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.plot3d-Tuple{Array}",
    "page": "Index",
    "title": "GMT.plot3d",
    "category": "method",
    "text": "plot3d(arg1::Array; kwargs...)\n\nreads (x,y,z) triplets from files [or standard input] and generates PostScript code that will plot lines, polygons, or symbols at those locations in 3-D.\n\nFull option list at psxyz\n\nParameters\n\nA : straight_lines : – Str –  \nBy default, geographic line segments are drawn as great circle arcs. To draw them as straight lines, use the -A flag.\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : – Str –\nGive a CPT or specify -Ccolor1,color2[,color3,...] to build a linear continuous CPT from those colors automatically.   -C\nD : offset : – Str –\nOffset the plot symbol or line locations by the given amounts dx/dy.\nE : error_bars : – Str –\nDraw symmetrical error bars.   -E\nF : conn : connection : – Str –\nAlter the way points are connected   -F\nG : fill : markerfacecolor : MarkerFaceColor : – Str –\nSelect color or pattern for filling of symbols or polygons. BUT WARN: the alias \'fill\' will set the   color of polygons OR symbols but not the two together. If your plot has polygons and symbols, use   \'fill\' for the polygons and \'markerfacecolor\' for filling the symbols. Same applyies for W bellow   -G\nI : intens : – Str or number –\nUse the supplied intens value (in the [-1 1] range) to modulate the fill color by simulating illumination.\nL : closed_polygon : – Str –\nForce closed polygons.    -L\nN : no_clip : –- Str or [] –\nDo NOT clip symbols that fall outside map border \nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nS : symbol : marker : Marker : – Str –\nPlot symbols (including vectors, pie slices, fronts, decorated or quoted lines).    -S   Alternatively select a sub-set of symbols using the aliases: marker or Marker and values:\n-, x_dash\n+, plus\na, *, star\nc, circle\nd, diamond\ng, octagon\nh, hexagon\ni, v, inverted_tri\nn, pentagon\np, ., point\nr, rectangle\ns, square\nt, ^, triangle\nx, cross\ny, y_dash\nW : line_attribs : markeredgecolor : MarkerEdgeColor : – Str –   Set pen attributes for lines or the outline of symbols   -W   WARNING: the pen attributes will set the pen of polygons OR symbols but not the two together.   If your plot has polygons and symbols, use W or line_attribs for the polygons and   markeredgecolor or MarkerEdgeColor for filling the symbols. Similar to S above.\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.psconvert",
    "page": "Index",
    "title": "GMT.psconvert",
    "category": "function",
    "text": "psconvert(cmd0::String=\"\", arg1=[]; kwargs...)\n\nPlace images or EPS files on maps.\n\nFull option list at psconvert\n\nParameters\n\nA : adjust : – Str or Number –  \nAdjust the BoundingBox and HiResBoundingBox to the minimum required by the image content.   -A\nC : gs_option : – Str or Array os strings –\nSpecify a single, or an araay of, custom option that will be passed on to GhostScript as is.   -C\nD : outdir*** : *outputdir : – Str –\nSets an alternative output directory (which must exist) [Default is the same directory   as the PS files].   -D\nE : dpi : – Number –\nSet raster resolution in dpi [default = 720 for PDF, 300 for others].   -E\nF : :out_name : output_name : – Str –\nForce the output file name.   -F\nG : ghost_path : – Bool or [] –\nFull path to your GhostScript executable.   -G\nI : icc_gray : – Bool or [] –\nEnforce gray-shades by using ICC profiles.   -I\nin_memory : – Bool or [] –\nProcess a in memory PS file. No other input file should be provided.   Currently works on Windows only.\nL : list_file : – Str –\nThe listfile is an ASCII file with the names of the PostScript files to be converted.   -L\nQ : anti_aliasing : – Str –\nSet the anti-aliasing options for graphics or text. Append the size of the subsample box   (1, 2, or 4) [4]. This option is set by default.   -Q\nS : gs_command : – Bool or [] –\nPrint to standard error the GhostScript command after it has been executed.   -S\nT : format : – Str –\nb|e|E|f|F|j|g|G|m|s|t Sets the output format, where b = BMP, e = EPS, E = EPS with PageSize command,   f = PDF, F = multi-page PDF, j = JPEG, g = PNG, G = transparent PNG (untouched regions are   transparent), m = PPM,  and t = TIFF [default is JPEG].   Alternatively, the format may be set with the fmt keyword, e.g. fmt=\"png\".   -T\nW : world_file : – Str –\nWrite a ESRI type world file suitable to make (e.g) .tif files be recognized as geotiff by   software that know how to do it.    -W\nkml – Str or [] –\nCreate a minimalist KML file that allows loading the image in GoogleEarth.   -W\nZ : delinputps : – Bool or [] –\nRemove the input PostScript file(s) after the conversion.   -Z\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\n\n\n\n\n\n"
},

{
    "location": "#GMT.image",
    "page": "Index",
    "title": "GMT.image",
    "category": "function",
    "text": "image(cmd0::String=\"\", arg1=[]; kwargs...)\n\nPlace images or EPS files on maps.\n\nFull option list at psimage\n\nParameters\n\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nD : ref_point : – Str –  \nSets reference point on the map for the image using one of four coordinate systems.   -D\nF : box : – Str or [] –\nWithout further options, draws a rectangular border around the image using MAPFRAMEPEN.   -F\nI : invert_1bit : – Number or Str –\nInvert 1-bit image before plotting.   -I\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nM : monochrome : – Bool or [] –\nConvert color image to monochrome grayshades using the (television) YIQ-transformation.   -M\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.mask",
    "page": "Index",
    "title": "GMT.mask",
    "category": "function",
    "text": "mask(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads (length,azimuth) pairs from file and plot a windmask diagram.\n\nFull option list at psmask\n\nParameters\n\nI : inc : – Str or Number –\nSet a fixed azimuth projection for masks [Default uses track azimuth, but see -A].   -I\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : endclippath : – Bool or [] –\nMark end of existing clip path. No input file is needed.   -C\nD : dump : – Str –\nDump the (x,y) coordinates of each clipping polygon to one or more output files   (or stdout if template is not given).   -D\nF : oriented_polygons : – Str or [] –\nForce clip contours (polygons) to be oriented so that data points are to the left (-Fl [Default]) or right (-Fr)    -F\nG : fill : – Number or Str –\nSet fill shade, color or pattern for positive and/or negative masks [Default is no fill].   -G\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nL : node_grid : – Str –\nSave the internal grid with ones (data constraint) and zeros (no data) to the named nodegrid.   -L\nN : invert : – Bool or [] –\nInvert the sense of the test, i.e., clip regions where there is data coverage.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : cut_number : – Number or Str –\nDo not dump polygons with less than cut number of points [Dumps all polygons].   -Q\nS : search_radius : – Number or Str –\nSets radius of influence. Grid nodes within radius of a data point are considered reliable.   -S\nT : tiles : – Bool or [] –\nPlot tiles instead of clip polygons. Use -G to set tile color or pattern. Cannot be used with -D.   -T\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.rose",
    "page": "Index",
    "title": "GMT.rose",
    "category": "function",
    "text": "rose(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads (length,azimuth) pairs and plot a windrose diagram.\n\nFull option list at psrose\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nA : sector : – Str or number –\nGives the sector width in degrees for sector and rose diagram.   -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : vectors : – Str –\nPlot vectors showing the principal directions given in the mode_file file.   -C\nD : shift : – Bool or [] –\nShift sectors so that they are centered on the bin interval (e.g., first sector is centered on 0 degrees).   -D\nF : no_scale : – Bool or [] –\nDo not draw the scale length bar [Default plots scale in lower right corner].   -F\nG : fill : – Number or Str –\nSelects shade, color or pattern for filling the sectors [Default is no fill].   -G\nI : inquire : – Bool or [] –\nInquire. Computes statistics needed to specify a useful -R. No plot is generated.   -I\nL : pen : – Number or Str –\nDraw bar outline using the specified pen thickness. [Default is no outline].   -L\nM : – Bool or [] –\nUsed with -C to modify vector parameters.   -M\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : alpha : – Str or [] –\nSets the confidence level used to determine if the mean resultant is significant.   -Q\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nS : radius : – Bool or [] –\nSpecifies radius of plotted circle (append a unit from c|i|p).   -S\nT : – Bool or [] –\nSpecifies that the input data are orientation data (i.e., have a 180 degree ambiguity)   instead of true 0-360 degree directions [Default].   -T\nW : pen : – Str or tuple –\nSet pen attributes for sector outline or rose plot. [Default is no outline].   -W\nZ : scale : – Str –\nMultiply the data radii by scale.   -Z\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.solar",
    "page": "Index",
    "title": "GMT.solar",
    "category": "function",
    "text": "solar(cmd0::String=\"\", arg1=[]; kwargs...)\n\nCalculate and plot the day-night terminator and the civil, nautical and astronomical twilights.\n\nFull option list at pssolar\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : vectors : – Str –\n-C\nG : fill : – Number or Str –\n-G\nI : inquire : – Bool or [] –\n-I\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nM : alpha : – Str or [] –\n-M\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nN : radius : – Bool or [] –\n-N\nT : – Bool or [] –\n-T\nW : pen : – Str or tuple –\n-W\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\no : output_col : – Str –     Flags = cols\nSelect specific data columns for primary output, in arbitrary order.   -o\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\n\n\n\n\n\n"
},

{
    "location": "#GMT.ternary",
    "page": "Index",
    "title": "GMT.ternary",
    "category": "function",
    "text": "ternary(cmd0::String=\"\", arg1=[]; kwargs...)\n\nreads (x,y) pairs and generates PostScript code that will plot lines, polygons, or symbols at those locations on a map.\n\nFull option list at ternary\n\nParameters\n\nA : straight_lines : – Str –  \nBy default, geographic line segments are drawn as great circle arcs. To draw them as straight   lines, use the -A flag.   -A\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nG : fill : markerfacecolor : MarkerFaceColor : – Str –\nSelect color or pattern for filling of symbols or polygons. BUT WARN: the alias \'fill\' will set the   color of polygons OR symbols but not the two together. If your plot has polygons and symbols, use   \'fill\' for the polygons and \'markerfacecolor\' for filling the symbols. Same applyies for W bellow   -G\nL : labels : – Str –            Flags = a/b/c\nSet the labels for the three diagram vertices [none].    -L\nM : no_plot : – Bool or [] –\nDo no plotting. Instead, convert the input (a,b,c[,z]) records to Cartesian (x,y,[,z]) records,   where x, y are normalized coordinates on the triangle (i.e., 0-1 in xand 0-sqrt(3)/2 in y).   -M\nN : no_clip : – Bool or [] –\nDo NOT clip symbols that fall outside map border    -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nS : symbol : marker : Marker : – Str –\nPlot symbols (including vectors, pie slices, fronts, decorated or quoted lines).    -S   Alternatively select a sub-set of symbols using the aliases: marker or Marker and values:\n-, x_dash\n+, plus\na, *, star\nc, circle\nd, diamond\ng, octagon\nh, hexagon\ni, v, inverted_tri\nn, pentagon\np, ., point\nr, rectangle\ns, square\nt, ^, triangle\nx, cross\ny, y_dash\nW : line_attrib : markeredgecolor : MarkerEdgeColor : – Str –\nSet pen attributes for lines or the outline of symbols   -W   WARNING: the pen attributes will set the pen of polygons OR symbols but not the two together.   If your plot has polygons and symbols, use W or line_attribs for the polygons and   markeredgecolor or MarkerEdgeColor for filling the symbols. Similar to S above.\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\naxis : aspect : – Str –   When equal to \"equal\" makes a square plot.\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.text",
    "page": "Index",
    "title": "GMT.text",
    "category": "function",
    "text": "text(cmd0::String=\"\", arg1=[]; kwargs...)\n\nPlots text strings of variable size, font type, and orientation. Various map projections are provided, with the option to draw and annotate the map boundaries.\n\nFull option list at pstext\n\nParameters\n\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nA : azimuths : – Bool or [] –\nAngles are given as azimuths; convert them to directions using the current projection.   -A\nC : clearance : – Str –\nSets the clearance between the text and the surrounding box [15%].   -C\nD : offset : – Str –\nOffsets the text from the projected (x,y) point by dx,dy [0/0].   -D\nF : text_attrib : – Str or number –\nSpecify up to three text attributes (font, angle, and justification).   -F\nG : fill : – Number or Str –\nSets the shade or color used for filling the text box [Default is no fill].   -G\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nL : list : – Bool or [] –\nLists the font-numbers and font-names available, then exits.   -L\nN : no_clip : –- Str or [] –\nDo NOT clip text at map boundaries.   -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nQ : change_case : –- Str –\nChange all text to either lower or upper case.   -Q\nT : text_box : –- Str –\nSpecify the shape of the textbox when using G and/or W.   -T\nW : line_attribs : – Str –\nSets the pen used to draw a rectangle around the text string.   -W\nZ : threeD : – Str –\nFor 3-D projections: expect each item to have its own level given in the 3rd column.   -Z\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.xy",
    "page": "Index",
    "title": "GMT.xy",
    "category": "function",
    "text": "xy(cmd0::String=\"\", arg1=[]; kwargs...)\n\nreads (x,y) pairs and plot lines, polygons, or symbols at those locations on a map.\n\nFull option list at psxy\n\nParameters\n\nA : straight_lines : – Str –  \nBy default, geographic line segments are drawn as great circle arcs. To draw them as straight   lines, use the -A flag.   -A\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : color : cmap : – Str –		Flags = cpt master+izinc color1color2*color3*\nName of the CPT (for grd_z only). Alternatively, supply the name of a GMT color   master dynamic CPT.   -C\nD : shift : offset : – Str –\nOffset the plot symbol or line locations by the given amounts dx/dy.   -D\nE : error_bars : – Str –\nDraw symmetrical error bars.   -E\nF : conn : connection : – Str –\nAlter the way points are connected   -F\nG : fill : markerfacecolor : – Str –\nSelect color or pattern for filling of symbols or polygons. BUT WARN: the alias \'fill\' will set the   color of polygons OR symbols but not the two together. If your plot has polygons and symbols, use   \'fill\' for the polygons and \'markerfacecolor\' for filling the symbols. Same applyies for W bellow   -G\nI : intens : – Str or number –\nUse the supplied intens value (in the [-1 1] range) to modulate the fill color by simulating   shading illumination.   -I\nL : closed_polygon : – Str –\nForce closed polygons.    -L\nN : no_clip : – Str or [] –\nDo NOT clip symbols that fall outside map border    -N\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nS : – Str –\nPlot symbols (including vectors, pie slices, fronts, decorated or quoted lines).    -S\nAlternatively select a sub-set of symbols using the aliases: symbol or marker and values:\n-, x_dash\n+, plus\na, *, star\nc, circle\nd, diamond\ng, octagon\nh, hexagon\ni, v, inverted_tri\nn, pentagon\np, ., point\nr, rectangle\ns, square\nt, ^, triangle\nx, cross\ny, y_dash\nand select their sizes with the markersize or size keyword [default is 8p].   The marker size can be a scalar or a vector with same size numeber of rows of data. Units are   points unless specified otherwise with (for example for cm) par=(PROJLENGTHUNIT=\"c\")\nW : pen : line_attrib : markeredgecolor : – Str –\nSet pen attributes for lines or the outline of symbols   -W   WARNING: the pen attributes will set the pen of polygons OR symbols but not the two together.   If your plot has polygons and symbols, use W or line_attribs for the polygons and   markeredgecolor for filling the symbols. Similar to S above.\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\naxis : aspect : – Str –   When equal to \"equal\" makes a square plot.\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.splitxyz",
    "page": "Index",
    "title": "GMT.splitxyz",
    "category": "function",
    "text": "splitxyz(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads a series of (x,y[,z]) records [or optionally (x,y,z,d,h)] and splits this into separate lists of (x,y[,z]) series, such that each series has a nearly constant azimuth through the x,y plane.\n\nFull option list at splitxyz\n\nParameters\n\nA : azim_tol : – Str or Array –  \nWrite out only those segments which are within +/- tolerance degrees of azimuth in heading,   measured clockwise from North, [0 - 360].   -A\nC : course_change : – Number –\nTerminate a segment when a course change exceeding course_change degrees of heading is detected.   -C\nD : min_dist : min_distance – Number –\nDo not write a segment out unless it is at least minimum_distance units long.   -D\nF : filter : – Str or Array –\nFilter the z values and/or the x,y values, assuming these are functions of d coordinate.   xyfilter and zfilter are filter widths in distance units.   -F\nQ : xyzdh : – Str –\nSpecify your desired output using any combination of xyzdh, in any order.   -Q\nS : dh : dist_head : – Bool or [] –\nBoth d and h are supplied. In this case, input contains x,y,z,d,h. [Default expects (x,y,z) input,   and d,h are computed from delta x, delta y.   -S\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nwrite : |> : Str –     Flags = fname\nSave result to ASCII file instead of returning to a Julia variable. Give file name as argument.   Use the bo option to save as a binary file.\nappend : Str –     Flags = fname\nAppend result to an existing file named fname instead of returning to a Julia variable.   Use the bo option to save as a binary file.\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ndo : nodata_out : – Str or Number –     Flags = nodata\nExamine all output columns and if any item equals NAN substitute it with   the chosen missing data value.   -do\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\ng : gaps : – Str –           Flags = axydXYDcolz+-gapu\nExamine the spacing between consecutive data points in order to impose breaks in the line.   -g\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.surface",
    "page": "Index",
    "title": "GMT.surface",
    "category": "function",
    "text": "surface(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads randomly-spaced (x,y,z) triples and produces a binary grid file of gridded values z(x,y) by solving:\n\n	(1 - T) * L (L (z)) + T * L (z) = 0\n\nFull option list at surface\n\nParameters\n\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nI : inc : – Str or Number –\nx_inc [and optionally y_inc] is the grid spacing.   -I\nA : aspect_ratio : – Number –\nAspect ratio. If desired, grid anisotropy can be added to the equations.   -A\nC : convergence : – Number –\nConvergence limit. Iteration is assumed to have converged when the maximum absolute change in any   grid value is less than convergence_limit.   -C\nG : outgrid : – Str –\nOutput grid file name. Note that this is optional and to be used only when saving   the result directly on disk. Otherwise, just use the G = surface(....) form.   -G\nLl : lower : – Str or Number –\nImpose limits on the output solution. lower sets the lower bound. lower can be the name of a grid   file with lower bound values, a fixed value, d to set to minimum input value,   -L\nLu : upper : – Str or Number –\n-L\nN : max_iterations : – Number –\nNumber of iterations. Iteration will cease when convergencelimit is reached or when number of   iterations reaches maxiterations.   -N\nQ : suggest : – Bool or [] –\nSuggest grid dimensions which have a highly composite greatest common factor.   -Q\nS : search_radius : – Number or Str –  \nSets the resolution of the projected grid that will be created.   -S\nT : tension : – Number or Str –\nTension factor[s]. These must be between 0 and 1.   -T\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nZ : over_relaxation : – Str or GMTgrid –\nOver-relaxation factor. This parameter is used to accelerate the convergence; it is a number between 1 and 2.   -Z\na : aspatial : – Str –			Flags = [col=]name[…] \nControl how aspatial data are handled in GMT during input and output.   -a\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.triangulate",
    "page": "Index",
    "title": "GMT.triangulate",
    "category": "function",
    "text": "triangulate(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads one or more ASCII [or binary] files (or standard input) containing x,y[,z] and performs Delaunay triangulation, i.e., it find how the points should be connected to give the most equilateral triangulation possible. \n\nFull option list at triangulate\n\nParameters\n\nC : slope_grid : – Number –\nRead a slope grid (in degrees) and compute the propagated uncertainty in the   bathymetry using the CURVE algorithm   -C\nD : derivatives : – Str –\nTake either the x- or y-derivatives of surface represented by the planar facets (only used when G is set).   -D\nE : empty : – Bool or [] –\nSet the value assigned to empty nodes when G is set [NaN].   -E\nG : grid : outgrid : – Str or [] –\nUse triangulation to grid the data onto an even grid (specified with R I).   Append the name of the output grid file.   -G\nI : inc : – Str or Number –\nx_inc [and optionally y_inc] is the grid spacing.   -I\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nM : network : – Bool or [] –\nOutput triangulation network as multiple line segments separated by a segment header record.   -M\nN : ids : – Bool or [] –\nUsed in conjunction with G to also write the triplets of the ids of all the Delaunay vertices   -N\nQ : voronoi : – Str or [] –\nOutput the edges of the Voronoi cells instead [Default is Delaunay triangle edges]   -Q\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nS : triangles : – Bool or [] –  \nOutput triangles as polygon segments separated by a segment header record. Requires Delaunay triangulation.   -S\nT : edges : – Bool or [] –\nOutput edges or polygons even if gridding has been selected with the G option   -T\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nZ : xyz : triplets : – Bool or [] –\n-Z\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\nbo : binary_out : – Str –			Flags = ncolstypew+L+B\nSelect native binary output.   -bo\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.wiggle",
    "page": "Index",
    "title": "GMT.wiggle",
    "category": "function",
    "text": "wiggle(cmd0::String=\"\", arg1=[]; kwargs...)\n\nReads (length,azimuth) pairs from file and plot a windwiggle diagram.\n\nFull option list at pswiggle\n\nParameters\n\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nZ : scale : – Number or Str –\nGives anomaly scale in data-units/distance-unit.   -Z\nA : azimuth : – Str or number –\nSets the preferred positive azimuth. Positive wiggles will “gravitate” towards that direction.   -A\nB : frame : axes : – Str –\nSet map boundary frame and axes attributes.   -B\nC : center : – Number –\nSubtract center from the data set before plotting [0].   -C\nD : scale_bar : – Str –\nDefines the reference point on the map for the vertical scale bar using one of four coordinate systems.   -D\nF : bar_rectangle : – Str –\nWithout further options, draws a rectangular border around the vertical scale bar.   -F\nG : fill : – Number or Str –\nSet fill shade, color or pattern for positive and/or negative wiggles [Default is no fill].   -G\nI : fixed_azim : – Number –\nSet a fixed azimuth projection for wiggles [Default uses track azimuth, but see -A].   -I\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nJz : z_axis : – Str –\nSet z-axis scaling.    -Jz\nP : portrait : –- Bool or [] –\nTell GMT to NOT draw in portriat mode (that is, make a Landscape plot)\nT : pen : – Number or Str or Tuple or [] –\nDraw track [Default is no track]. Append pen attributes to use [Defaults: width = 0.25p, color =   black, style = solid].   -T\nW : pen : – Number or Str or tuple or [] –\nSpecify outline pen attributes [Default is no outline].   -W\nU : stamp : – Str or Bool or [] –	Flags = justdxdyclabel\nDraw GMT time stamp logo on plot.   -U\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nX : x_offset : – Str –Flags = [a|c|f|r][x-shift[u]]\nY : y_offset : – Str –Flags = [a|c|f|r][y-shift[u]]\nShift plot origin relative to the current origin by (x-shift,y-shift) and optionally   append the length unit (c, i, or p).    -Y\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\np : view : perspective : – Str or List –   Flags = xyzazimelevzlevel+wlon0lat0z0+vx0y0\nSelects perspective view and sets the azimuth and elevation of the viewpoint [180/90].   -p\nt : alpha : transparency : – Str –   Flags = transp\nSet PDF transparency level for an overlay, in (0-100] percent range. [Default is 0, i.e., opaque].   -t\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#GMT.xyz2grd",
    "page": "Index",
    "title": "GMT.xyz2grd",
    "category": "function",
    "text": "xyz2grd(cmd0::String=\"\", arg1=[]; kwargs...)\n\nConvert data table to a grid file. \n\nFull option list at xyz2grd\n\nParameters\n\nI : inc : – Str or Number –     Flags = xinc[unit][+e|n][/yinc[unit][+e|n]]\nx_inc [and optionally y_inc] is the grid spacing.   -I\nR : region : limits : – Str or list or GMTgrid|image –		Flags = xminxmaxyminymax+r+uunit\nSpecify the region of interest. Set to data minimum BoundinBox if not provided.   -R\nA : multiple_nodes : – Str –      Flags = [d|f|l|m|n|r|S|s|u|z]\nBy default we will calculate mean values if multiple entries fall on the same node.   Use A to change this behavior.   -A\nD : header : – Str –  Flags = [+xxname][+yyname][+zzname][+sscale][+ooffset][+ninvalid][+ttitle][+rremark]\nOutput edges   -D\nG : outgrid : – Str –\nOutput grid file name. Note that this is optional and to be used only when saving   the result directly on disk. Otherwise, just use the G = grdclip(....) form.   -G\nJ : proj : projection : – Str –\nSelect map projection. Defaults to 12x8 cm with linear (non-projected) maps.   -J\nS : swap : – Str or [] –        Flags = [zfile]\nSwap the byte-order of the input only. No grid file is produced.   -S\nV : verbose : – Bool or Str –		Flags = level\nSelect verbosity level, which will send progress reports to stderr.   -V\nZ : flags : – Str –\nRead a 1-column table. This assumes that all the nodes are present and sorted according to specified ordering convention contained in. flags.   -Z\nbi : binary_in : – Str –			Flags = [ncols][type][w][+L|+B]\nSelect native binary format for primary input (secondary inputs are always ASCII).   -bi\ndi : nodata_in : – Str or Number –      Flags = nodata\nExamine all input columns and if any item equals nodata we interpret this value as a   missing data item and substitute the value NaN.   -di\ne : pattern : – Str –        Flags = pattern  -eregexpi\nOnly accept ASCII data records that contains the specified pattern.   -e\nf : colinfo : – Str –        Flags = iocolinfo\nSpecify the data types of input and/or output columns (time or geographical data).   -f\nh : headers : – Str –        Flags = ion+c+d+rremark+ttitle\nPrimary input file(s) has header record(s).   -h\ni : input_col : – Str –      Flags = cols+l+sscale+ooffset\nSelect specific data columns for primary input, in arbitrary order.   -i\nr : reg : registration : – Bool or [] –\nForce pixel node registration [Default is gridline registration].   -r\nswap_xy : Str or Bool or [] –     Flags = io\nSwap 1st and 2nd column on input and/or output.   -:\n\n\n\n\n\n"
},

{
    "location": "#Functions-1",
    "page": "Index",
    "title": "Functions",
    "category": "section",
    "text": "basemap(cmd0::String=\"\"; kwargs...)blockmean(cmd0::String=\"\", arg1=[]; kwargs...)blockmedian(cmd0::String=\"\", arg1=[]; kwargs...)blockmode(cmd0::String=\"\", arg1=[]; kwargs...)clip(cmd0::String=\"\", arg1=[]; kwargs...)coast(cmd0::String=\"\"; clip=[], kwargs...)colorbar(cmd0::String=\"\", arg1=[]; kwargs...)filter1d(cmd0::String=\"\", arg1=[], kwargs...)fitcircle(cmd0::String=\"\", arg1=[], kwargs...)gmt2kml(cmd0::String=\"\", arg1=[], kwargs...)gmtconnect(cmd0::String=\"\", arg1=[], kwargs...)gmtconvert(cmd0::String=\"\", arg1=[], kwargs...)gmtinfo(cmd0::String=\"\", arg1=[]; kwargs...)logo(cmd0::String=\"\"; kwargs...)gmtread(fname::String, data; kwargs...)gmtwrite(fname::String, data; kwargs...)regress(cmd0::String=\"\", arg1=[], kwargs...)gmtselect(cmd0::String=\"\", arg1=[], kwargs...)gmtset(cmd0::String=\"\", kwargs...)gmtsimplify(cmd0::String=\"\", arg1=[], kwargs...)gmtspatial(cmd0::String=\"\", arg1=[], kwargs...)gmtvector(cmd0::String=\"\", arg1=[], kwargs...)gmtwich(cmd0::String=\"\", arg1=[], kwargs...)grd2cpt(cmd0::String=\"\", arg1=[], kwargs...)grd2kml(cmd0::String=\"\", arg1=[], kwargs...)grd2xyz(cmd0::String=\"\", arg1=[], kwargs...)grdblend(cmd0::String=\"\", arg1=[], arg2=[], kwargs...)grdclip(cmd0::String=\"\", arg1=[], kwargs...)grdcontour(cmd0::String=\"\", arg1=[]; kwargs...)grdcut(cmd0::String=\"\", arg1=[], kwargs...)grdedit(cmd0::String=\"\", arg1=[], kwargs...)grdfft(cmd0::String=\"\", arg1=[], [arg2=[]], kwargs...)grdfilter(cmd0::String=\"\", arg1=[], kwargs...)grdgradient(cmd0::String=\"\", arg1=[], kwargs...)grdhisteq(cmd0::String=\"\", arg1=[], kwargs...)grdimage(cmd0::String=\"\", arg1=[], arg2=[], arg3=[], arg4=[]; kwargs...)grdinfo(cmd0::String=\"\", arg1=[]; kwargs...)grdlandmask(cmd0::String=\"\", arg1=[], kwargs...)grdpaste(cmd0::String=\"\", arg1=[], arg2=[], kwargs...)grdproject(cmd0::String=\"\", arg1=[], kwargs...)grdsample(cmd0::String=\"\", arg1=[], kwargs...)grdtrack(cmd0::String=\"\", arg1=[], arg2=[]; kwargs...)grdtrend(cmd0::String=\"\", arg1=[], arg2=[]; kwargs...)grdvector(cmd0::String=\"\", arg1=nothing, arg2=nothing, kwargs...)grdview(cmd0::String=\"\", arg1=[], arg2=[], arg3=[], arg4=[], arg5=[], arg6=[]; kwargs...)grdvolume(cmd0::String=\"\", arg1=[], kwargs...)greenspline(cmd0::String=\"\", arg1=[]; kwargs...)histogram(cmd0::String=\"\", arg1=[]; kwargs...)imshow(arg1; kwargs...)kml2gmt(cmd0::String=\"\", arg1=[], kwargs...)makecpt(cmd0::String=\"\", arg1=[]; kwargs...)mapproject(cmd0::String=\"\", arg1=[], kwargs...)nearneighbor(cmd0::String=\"\", arg1=[]; kwargs...)plot(arg1::Array; kwargs...)plot3d(arg1::Array; kwargs...)project(cmd0::String=\"\", arg1=[], kwargs...)psconvert(cmd0::String=\"\", arg1=[]; kwargs...)image(cmd0::String=\"\", arg1=[]; kwargs...)mask(cmd0::String=\"\", arg1=[]; kwargs...)rose(cmd0::String=\"\", arg1=[]; kwargs...)solar(cmd0::String=\"\", arg1=[]; kwargs...)ternary(cmd0::String=\"\", arg1=[]; kwargs...)text(cmd0::String=\"\", arg1=[]; kwargs...)xy(cmd0::String=\"\", arg1=[]; kwargs...)sample1d(cmd0::String=\"\", arg1=[], kwargs...)scatter(cmd0::String=\"\", arg1=[], kwargs...)spectrum1d(cmd0::String=\"\", arg1=[], kwargs...)sphdistance(cmd0::String=\"\", arg1=[], kwargs...)sphinterpolate(cmd0::String=\"\", arg1=[], kwargs...)splitxyz(cmd0::String=\"\", arg1=[]; kwargs...)surface(cmd0::String=\"\", arg1=[]; kwargs...)trend1d(cmd0::String=\"\", arg1=[], kwargs...)trend2d(cmd0::String=\"\", arg1=[], kwargs...)triangulate(cmd0::String=\"\", arg1=[]; kwargs...)wiggle(cmd0::String=\"\", arg1=[]; kwargs...)xyz2grd(cmd0::String=\"\", arg1=[]; kwargs...)"
},

]}
